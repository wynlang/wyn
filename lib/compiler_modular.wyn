// Wyn Self-Hosting Compiler - Modular Version
// Real integrated compiler with file I/O
// Simplified standalone version without module imports

// Helper: Check if character is whitespace
fn is_whitespace(ch: string) -> int {
    if ch == " " { return 1 }
    if ch == "\n" { return 1 }
    if ch == "\t" { return 1 }
    if ch == "\r" { return 1 }
    return 0
}

// Helper: Check if character is digit
fn is_digit(ch: string) -> int {
    if ch >= "0" && ch <= "9" { return 1 }
    return 0
}

// Helper: Check if character is alpha
fn is_alpha(ch: string) -> int {
    if ch >= "a" && ch <= "z" { return 1 }
    if ch >= "A" && ch <= "Z" { return 1 }
    if ch == "_" { return 1 }
    return 0
}

// Generate C code from Wyn source
fn generate_c_code(source: string) -> string {
    var output = ""
    
    // Always emit includes
    output = output + "#include <stdio.h>\n"
    output = output + "#include <stdlib.h>\n"
    output = output + "#include <string.h>\n\n"
    
    // Generate main function wrapper
    output = output + "int main() {\n"
    
    // Parse and generate code for each statement
    var pos = 0
    while pos < source.len() {
        // Skip whitespace
        while pos < source.len() && is_whitespace(source[pos]) == 1 {
            pos = pos + 1
        }
        
        if pos >= source.len() {
            break
        }
        
        // Check for "var" keyword
        if pos + 3 <= source.len() && source[pos] == "v" && source[pos + 1] == "a" && source[pos + 2] == "r" {
            pos = pos + 3
            
            // Skip whitespace
            while pos < source.len() && is_whitespace(source[pos]) == 1 {
                pos = pos + 1
            }
            
            // Extract variable name
            var var_name = ""
            while pos < source.len() && is_alpha(source[pos]) == 1 {
                var_name = var_name + source[pos]
                pos = pos + 1
            }
            
            // Skip whitespace and equals
            while pos < source.len() && (is_whitespace(source[pos]) == 1 || source[pos] == "=") {
                pos = pos + 1
            }
            
            // Extract value
            var value = ""
            while pos < source.len() && is_digit(source[pos]) == 1 {
                value = value + source[pos]
                pos = pos + 1
            }
            
            // Generate C code
            output = output + "    int " + var_name + " = " + value + ";\n"
        } else {
            pos = pos + 1
        }
    }
    
    output = output + "    return 0;\n"
    output = output + "}\n"
    
    return output
}

// Extract filename without extension
fn get_base_name(path: string) -> string {
    var len = path.len()
    var dot_pos = -1
    var i = len - 1
    
    // Find last dot
    while i >= 0 {
        if path[i] == "." {
            dot_pos = i
            break
        }
        i = i - 1
    }
    
    if dot_pos == -1 {
        return path
    }
    
    return path.substring(0, dot_pos)
}

fn compile(source_path: string) -> int {
    print("Compiling: ")
    print(source_path)
    
    // Step 1: Read source file
    var source = File::read(source_path)
    
    if source.len() == 0 {
        print("Error: Could not read source file")
        return 1
    }
    
    print("Source length: ")
    print(source.len())
    
    // Step 2: Generate C code
    var c_code = generate_c_code(source)
    
    print("Generated C code length: ")
    print(c_code.len())
    
    // Step 3: Write output file
    var output_path = get_base_name(source_path) + ".c"
    var write_result = File::write(output_path, c_code)
    
    if write_result == 0 {
        print("Error: Could not write output file")
        return 1
    }
    
    print("Compilation successful: ")
    print(output_path)
    
    return 0
}

fn main() -> int {
    // Get source file from command line argument
    // For now, use a test file path
    var source_path = "/tmp/test_input.wyn"
    
    var result = compile(source_path)
    
    return result
}

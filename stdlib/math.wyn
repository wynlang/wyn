// Math module

fn abs(n: int) -> int {
    if n < 0 {
        return 0 - n;
    }
    return n;
}

fn max(a: int, b: int) -> int {
    if a > b {
        return a;
    }
    return b;
}

fn min(a: int, b: int) -> int {
    if a < b {
        return a;
    }
    return b;
}

fn pow(base: int, exp: int) -> int {
    let mut result = 1;
    let mut i = 0;
    while i < exp {
        result = result * base;
        i = i + 1;
    }
    return result;
}

fn sqrt(n: int) -> int {
    if n < 2 {
        return n;
    }
    let mut x = n;
    let mut y = (x + 1) / 2;
    while y < x {
        x = y;
        y = (x + n / x) / 2;
    }
    return x;
}

fn gcd(a: int, b: int) -> int {
    let mut x = a;
    let mut y = b;
    while y != 0 {
        let temp = y;
        y = x - (x / y) * y;
        x = temp;
    }
    return x;
}

fn lcm(a: int, b: int) -> int {
    return (a * b) / gcd(a, b);
}

fn factorial(n: int) -> int {
    if n <= 1 {
        return 1;
    }
    let mut result = 1;
    let mut i = 2;
    while i <= n {
        result = result * i;
        i = i + 1;
    }
    return result;
}

fn is_prime(n: int) -> int {
    if n < 2 {
        return 0;
    }
    if n == 2 {
        return 1;
    }
    if n - (n / 2) * 2 == 0 {
        return 0;
    }
    let mut i = 3;
    let limit = sqrt(n);
    while i <= limit {
        if n - (n / i) * i == 0 {
            return 0;
        }
        i = i + 2;
    }
    return 1;
}

fn clamp(val: int, min_val: int, max_val: int) -> int {
    if val < min_val {
        return min_val;
    }
    if val > max_val {
        return max_val;
    }
    return val;
}

fn sign(n: int) -> int {
    if n < 0 {
        return -1;
    }
    if n > 0 {
        return 1;
    }
    return 0;
}


// Additional math utilities

fn max3(a: int, b: int, c: int) -> int {
    let m = max(a, b);
    return max(m, c);
}

fn min3(a: int, b: int, c: int) -> int {
    let m = min(a, b);
    return min(m, c);
}

fn avg(a: int, b: int) -> int {
    return (a + b) / 2;
}

fn avg3(a: int, b: int, c: int) -> int {
    return (a + b + c) / 3;
}

fn cube(n: int) -> int {
    return n * n * n;
}

fn square(n: int) -> int {
    return n * n;
}

fn is_even(n: int) -> int {
    let rem = n - (n / 2) * 2;
    if rem == 0 {
        return 1;
    }
    return 0;
}

fn is_odd(n: int) -> int {
    let even = is_even(n);
    if even == 1 {
        return 0;
    }
    return 1;
}

fn div_ceil(a: int, b: int) -> int {
    let q = a / b;
    let r = a - q * b;
    if r > 0 {
        return q + 1;
    }
    return q;
}

fn div_floor(a: int, b: int) -> int {
    return a / b;
}

fn mod_positive(a: int, b: int) -> int {
    let r = a - (a / b) * b;
    if r < 0 {
        return r + b;
    }
    return r;
}

fn fibonacci(n: int) -> int {
    if n <= 1 {
        return n;
    }
    let mut a = 0;
    let mut b = 1;
    let mut i = 2;
    while i <= n {
        let temp = a + b;
        a = b;
        b = temp;
        i = i + 1;
    }
    return b;
}

fn sum_range(n: int) -> int {
    return n * (n + 1) / 2;
}

fn sum_squares(n: int) -> int {
    return n * (n + 1) * (2 * n + 1) / 6;
}

fn nth_triangular(n: int) -> int {
    return n * (n + 1) / 2;
}

fn nth_pentagonal(n: int) -> int {
    return n * (3 * n - 1) / 2;
}

fn nth_hexagonal(n: int) -> int {
    return n * (2 * n - 1);
}

fn binomial(n: int, k: int) -> int {
    if k > n {
        return 0;
    }
    if k == 0 {
        return 1;
    }
    if k > n - k {
        return binomial(n, n - k);
    }
    let mut result = 1;
    let mut i = 0;
    while i < k {
        result = result * (n - i);
        result = result / (i + 1);
        i = i + 1;
    }
    return result;
}

fn catalan(n: int) -> int {
    if n <= 1 {
        return 1;
    }
    let c = binomial(2 * n, n);
    return c / (n + 1);
}


// Bit manipulation utilities

fn bit_count(n: int) -> int {
    let mut count = 0;
    let mut num = n;
    while num != 0 {
        let bit = num - (num / 2) * 2;
        if bit == 1 {
            count = count + 1;
        }
        num = num / 2;
    }
    return count;
}

fn bit_set(n: int, pos: int) -> int {
    let mask = pow(2, pos);
    return n | mask;
}

fn bit_clear(n: int, pos: int) -> int {
    let mask = pow(2, pos);
    return n & (0 - mask - 1);
}

fn bit_toggle(n: int, pos: int) -> int {
    let mask = pow(2, pos);
    return n ^ mask;
}

fn bit_test(n: int, pos: int) -> int {
    let mask = pow(2, pos);
    let result = n & mask;
    if result != 0 {
        return 1;
    }
    return 0;
}

fn next_power_of_2(n: int) -> int {
    if n <= 1 {
        return 1;
    }
    let mut p = 1;
    while p < n {
        p = p * 2;
    }
    return p;
}

fn is_power_of_2(n: int) -> int {
    if n <= 0 {
        return 0;
    }
    let and_result = n & (n - 1);
    if and_result == 0 {
        return 1;
    }
    return 0;
}

fn log2_floor(n: int) -> int {
    if n <= 0 {
        return -1;
    }
    let mut count = 0;
    let mut num = n;
    while num > 1 {
        num = num / 2;
        count = count + 1;
    }
    return count;
}

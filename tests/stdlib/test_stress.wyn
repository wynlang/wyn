fn fib(n: int) -> int { if n <= 1 { return n } return fib(n-1) + fib(n-2) }
fn dbl(x: int) -> int { return x * 2 }
fn neg(x: int) -> int { return 0 - x }
fn is_pos(x: int) -> int { return x > 0 }

struct Point { x: int, y: int }

fn divide(a: int, b: int) -> ResultInt {
    if b == 0 { return Err("zero") }
    return Ok(a / b)
}

fn chain_divide(x: int) -> ResultInt {
    var a = divide(x, 2)?
    var b = divide(a, 3)?
    return Ok(b)
}

fn make_adder(n: int) -> fn(int) -> int {
    return fn(x: int) -> int { return x + n }
}

var g_val = 0
fn inc_global() { g_val = g_val + 1 }
fn inc_ref(mut x: int) { x = x + 1 }

fn worker(shared: int, amount: int) -> int {
    Task.add(shared, amount)
    return 0
}

fn main() -> int {
    Test.init("Stress Test")
    
    // === EDGE: Empty/null operations ===
    Test.assert_eq_str("".upper(), "", "empty upper")
    Test.assert_eq_str("".trim(), "", "empty trim")
    Test.assert_eq_int("".len(), 0, "empty len")
    Test.assert_eq_int("".to_int(), 0, "empty to_int")
    Test.assert_eq_str("".reverse(), "", "empty reverse")
    Test.assert_eq_str("".replace("a","b"), "", "empty replace")
    Test.assert_eq_int("".index_of("x"), -1, "empty index_of")
    
    // === EDGE: Single char ===
    Test.assert_eq_str("a".upper(), "A", "single upper")
    Test.assert_eq_str("Z".lower(), "z", "single lower")
    Test.assert_eq_str("x".repeat(0), "", "repeat 0")
    Test.assert_eq_str("x".repeat(1), "x", "repeat 1")
    
    // === EDGE: Negative numbers ===
    Test.assert_eq_int(Math.abs(-999999999), 999999999, "abs large neg")
    Test.assert_eq_int(Math.max(-100, -1), -1, "max negatives")
    Test.assert_eq_int(-10 / 3, -3, "neg division")
    Test.assert_eq_int(-10 % 3, -1, "neg modulo")
    
    // === EDGE: 64-bit boundaries ===
    var big = 9999999999999
    Test.assert_eq_str(big.to_string(), "9999999999999", "big to_string")
    var neg_big = -9999999999999
    Test.assert_eq_str(neg_big.to_string(), "-9999999999999", "neg big to_string")
    Test.assert_eq_int(2147483647 + 1, 2147483648, "32-bit overflow safe")
    
    // === EDGE: Array boundaries ===
    var arr = [10]
    Test.assert_eq_int(arr.len(), 1, "single elem arr")
    Test.assert_eq_int(arr[0], 10, "single elem get")
    arr[0] = 99
    Test.assert_eq_int(arr[0], 99, "single elem set")
    Test.assert_eq_int(arr.pop(), 99, "pop single")
    Test.assert_eq_int(arr.len(), 0, "empty after pop")
    
    // === EDGE: Array methods on empty ===
    var empty = [0]
    empty.pop()
    Test.assert_eq_int([1,2,3].index_of(99), -1, "index_of missing")
    Test.assert_eq_int([1,1,1].unique().len(), 1, "all same unique")
    Test.assert_eq_str([].join(","), "", "empty join")
    
    // === EDGE: HashMap missing keys ===
    var m = HashMap.new()
    Test.assert_eq_int(m.get_int("x"), 0, "missing int = 0")
    Test.assert_eq_str(m.get("x"), "", "missing str = empty")
    Test.assert_eq_int(m.contains("x"), 0, "missing contains")
    Test.assert_eq_int(m.len(), 0, "empty map len")
    m.insert_int("k", 0)
    Test.assert_eq_int(m.get_int("k"), 0, "stored 0")
    Test.assert(m.contains("k"), "contains 0-value")
    
    // === EDGE: Result/Option with 0 ===
    var ok_zero: ResultInt = Ok(0)
    Test.assert(ok_zero.is_ok(), "Ok(0) is ok")
    Test.assert_eq_int(ok_zero.unwrap(), 0, "Ok(0) unwrap")
    var some_zero: OptionInt = Some(0)
    Test.assert(some_zero.is_some(), "Some(0) is some")
    Test.assert_eq_int(some_zero.unwrap(), 0, "Some(0) unwrap")
    
    // === EDGE: ? operator chain ===
    var r1 = chain_divide(60)
    Test.assert_eq_int(r1.unwrap(), 10, "? chain 60/2/3=10")
    var r2 = chain_divide(0)
    Test.assert(r2.is_ok(), "? chain 0/2=0, 0/3=0")
    
    // === EDGE: Closures ===
    var add5 = make_adder(5)
    var add0 = make_adder(0)
    Test.assert_eq_int(add5(10), 15, "closure +5")
    Test.assert_eq_int(add0(10), 10, "closure +0")
    Test.assert_eq_int(add5(0), 5, "closure 0+5")
    
    // === EDGE: Globals + mut refs ===
    inc_global()
    inc_global()
    inc_global()
    Test.assert_eq_int(g_val, 3, "global 3x")
    var n = 0
    inc_ref(&n)
    inc_ref(&n)
    Test.assert_eq_int(n, 2, "mut ref 2x")
    
    // === EDGE: String chaining ===
    Test.assert_eq_str("  HELLO  ".trim().lower(), "hello", "trim.lower")
    Test.assert_eq_str("abc".upper().reverse(), "CBA", "upper.reverse")
    Test.assert_eq_str("hello world".split(",")[0], "hello world", "split no match")
    
    // === EDGE: Struct arrays ===
    var pts = [Point{x:1,y:2}, Point{x:3,y:4}]
    Test.assert_eq_int(pts[0].x, 1, "struct arr field")
    pts[0] = Point{x:99,y:100}
    Test.assert_eq_int(pts[0].x, 99, "struct arr assign")
    
    // === EDGE: Recursion depth ===
    Test.assert_eq_int(fib(20), 6765, "fib(20)")
    
    // === EDGE: Map/filter/reduce chains ===
    var data = [1, -2, 3, -4, 5]
    // Actually reduce(fn(a,b)->int, init) â€” dbl is wrong. Let me use a proper fn
    
    // === EDGE: Spawn correctness ===
    var shared = Task.value(0)
    var f1 = spawn worker(shared, 100)
    var f2 = spawn worker(shared, 200)
    var f3 = spawn worker(shared, 300)
    await f1
    await f2
    await f3
    Test.assert_eq_int(Task.get(shared), 600, "3 spawns = 600")
    
    // === EDGE: File operations ===
    File.write("/tmp/wyn_stress.txt", "line1\nline2\nline3\n")
    var fh = File.open("/tmp/wyn_stress.txt", "r")
    var l1 = File.read_line(fh).trim()
    var l2 = File.read_line(fh).trim()
    var l3 = File.read_line(fh).trim()
    Test.assert_eq_str(l1, "line1", "readline 1")
    Test.assert_eq_str(l2, "line2", "readline 2")
    Test.assert_eq_str(l3, "line3", "readline 3")
    File.close(fh)
    File.delete("/tmp/wyn_stress.txt")
    Test.assert_eq_int(File.exists("/tmp/wyn_stress.txt"), 0, "deleted")
    
    // === EDGE: Nonexistent paths ===
    Test.assert_eq_int(File.exists("/no/such/file"), 0, "no file")
    Test.assert_eq_int(File.is_dir("/no/such/dir"), 0, "no dir")
    Test.assert_eq_int(File.size("/no/such/file"), 0, "no file size")
    
    // === EDGE: Regex edge cases ===
    Test.assert_eq_int(Regex.match("", ".*"), 1, "empty matches .*")
    Test.assert_eq_int(Regex.find("abc", "xyz"), -1, "find no match")
    
    // === EDGE: Json parse edge cases ===
    var empty_obj = Json.parse("{}")
    Test.assert_eq_int(Json.has(empty_obj, "x"), 0, "empty obj has")
    Test.assert_eq_str(Json.get(empty_obj, "x"), "", "empty obj get")
    
    // === EDGE: Encoding roundtrip ===
    var original = "Hello, World! 123"
    var enc = Encoding.base64_encode(original)
    var dec = Encoding.base64_decode(enc)
    Test.assert_eq_str(dec, original, "b64 roundtrip")
    
    // === EDGE: Boolean comparisons ===
    Test.assert(1 == 1, "1==1")
    Test.assert(1 != 2, "1!=2")
    Test.assert(5 > 3, "5>3")
    Test.assert(3 < 5, "3<5")
    Test.assert(5 >= 5, "5>=5")
    Test.assert(5 <= 5, "5<=5")
    Test.assert("abc" == "abc", "str ==")
    Test.assert("abc" != "def", "str !=")
    
    // === EDGE: String interpolation ===
    var name = "Wyn"
    var ver = 2
    Test.assert_eq_str("${name} v${ver}", "Wyn v2", "interpolation")
    
    // === EDGE: Break/continue ===
    var found = -1
    for i in 0..10 { if i == 7 { found = i break } }
    Test.assert_eq_int(found, 7, "break at 7")
    var sum = 0
    for i in 0..10 { if i % 2 == 0 { continue } sum = sum + i }
    Test.assert_eq_int(sum, 25, "continue odds")
    
    Test.summary()
    return 0
}

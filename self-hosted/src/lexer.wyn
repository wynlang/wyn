// Lexer - Returns tokens for parser
// Workaround: Avoid variable names that trigger codegen bugs

struct Tokens {
    types: [int],
    lines: [int],
    cols: [int],
    count: int
}

fn is_digit(c: string) -> int {
    if str_eq(c, "0") == 1 { return 1 }
    if str_eq(c, "1") == 1 { return 1 }
    if str_eq(c, "2") == 1 { return 1 }
    if str_eq(c, "3") == 1 { return 1 }
    if str_eq(c, "4") == 1 { return 1 }
    if str_eq(c, "5") == 1 { return 1 }
    if str_eq(c, "6") == 1 { return 1 }
    if str_eq(c, "7") == 1 { return 1 }
    if str_eq(c, "8") == 1 { return 1 }
    if str_eq(c, "9") == 1 { return 1 }
    return 0
}

fn is_alpha(c: string) -> int {
    if str_eq(c, "a") == 1 { return 1 }
    if str_eq(c, "b") == 1 { return 1 }
    if str_eq(c, "c") == 1 { return 1 }
    if str_eq(c, "d") == 1 { return 1 }
    if str_eq(c, "e") == 1 { return 1 }
    if str_eq(c, "f") == 1 { return 1 }
    if str_eq(c, "g") == 1 { return 1 }
    if str_eq(c, "h") == 1 { return 1 }
    if str_eq(c, "i") == 1 { return 1 }
    if str_eq(c, "j") == 1 { return 1 }
    if str_eq(c, "k") == 1 { return 1 }
    if str_eq(c, "l") == 1 { return 1 }
    if str_eq(c, "m") == 1 { return 1 }
    if str_eq(c, "n") == 1 { return 1 }
    if str_eq(c, "o") == 1 { return 1 }
    if str_eq(c, "p") == 1 { return 1 }
    if str_eq(c, "q") == 1 { return 1 }
    if str_eq(c, "r") == 1 { return 1 }
    if str_eq(c, "s") == 1 { return 1 }
    if str_eq(c, "t") == 1 { return 1 }
    if str_eq(c, "u") == 1 { return 1 }
    if str_eq(c, "v") == 1 { return 1 }
    if str_eq(c, "w") == 1 { return 1 }
    if str_eq(c, "x") == 1 { return 1 }
    if str_eq(c, "y") == 1 { return 1 }
    if str_eq(c, "z") == 1 { return 1 }
    if str_eq(c, "_") == 1 { return 1 }
    return 0
}

fn keyword_type(word: string) -> int {
    if str_eq(word, "fn") == 1 { return 5 }
    if str_eq(word, "var") == 1 { return 6 }
    if str_eq(word, "if") == 1 { return 7 }
    if str_eq(word, "else") == 1 { return 8 }
    if str_eq(word, "while") == 1 { return 12 }
    if str_eq(word, "return") == 1 { return 14 }
    return 0
}

fn lex(source: string) -> Tokens {
    var types = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    var lines = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    var cols = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    
    var slen = string_length(source)
    var pos = 0
    var cnt = 0
    var ln = 1
    var cl = 1
    
    while pos < slen {
        var c = source.char_at(pos)
        
        if str_eq(c, " ") == 1 {
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "\n") == 1 {
            pos = pos + 1
            ln = ln + 1
            cl = 1
        } else if str_eq(c, "\t") == 1 {
            pos = pos + 1
            cl = cl + 1
        } else if is_digit(c) == 1 {
            types[cnt] = 0
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
            var done = 0
            while done == 0 {
                if pos >= slen {
                    done = 1
                } else {
                    var d = source.char_at(pos)
                    if is_digit(d) == 1 {
                        pos = pos + 1
                        cl = cl + 1
                    } else {
                        done = 1
                    }
                }
            }
        } else if is_alpha(c) == 1 {
            var word = c
            var start_cl = cl
            pos = pos + 1
            cl = cl + 1
            var done = 0
            while done == 0 {
                if pos >= slen {
                    done = 1
                } else {
                    var d = source.char_at(pos)
                    if is_alpha(d) == 1 {
                        word = str_concat(word, d)
                        pos = pos + 1
                        cl = cl + 1
                    } else if is_digit(d) == 1 {
                        word = str_concat(word, d)
                        pos = pos + 1
                        cl = cl + 1
                    } else {
                        done = 1
                    }
                }
            }
            
            var kw = keyword_type(word)
            if kw != 0 {
                types[cnt] = kw
            } else {
                types[cnt] = 9
            }
            lines[cnt] = ln
            cols[cnt] = start_cl
            cnt = cnt + 1
        } else if str_eq(c, "+") == 1 {
            types[cnt] = 23
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "-") == 1 {
            // Check for ->
            if pos + 1 < slen {
                var next = source.char_at(pos + 1)
                if str_eq(next, ">") == 1 {
                    types[cnt] = 46
                    lines[cnt] = ln
                    cols[cnt] = cl
                    cnt = cnt + 1
                    pos = pos + 2
                    cl = cl + 2
                } else {
                    types[cnt] = 24
                    lines[cnt] = ln
                    cols[cnt] = cl
                    cnt = cnt + 1
                    pos = pos + 1
                    cl = cl + 1
                }
            } else {
                types[cnt] = 24
                lines[cnt] = ln
                cols[cnt] = cl
                cnt = cnt + 1
                pos = pos + 1
                cl = cl + 1
            }
        } else if str_eq(c, "*") == 1 {
            types[cnt] = 25
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "/") == 1 {
            types[cnt] = 26
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "%") == 1 {
            types[cnt] = 27
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "(") == 1 {
            types[cnt] = 18
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, ")") == 1 {
            types[cnt] = 19
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "{") == 1 {
            types[cnt] = 16
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "}") == 1 {
            types[cnt] = 17
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, ":") == 1 {
            types[cnt] = 45
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, ",") == 1 {
            types[cnt] = 44
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, ";") == 1 {
            types[cnt] = 11
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "[") == 1 {
            types[cnt] = 20
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "]") == 1 {
            types[cnt] = 21
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, ".") == 1 {
            types[cnt] = 43
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "=") == 1 {
            // Check for ==
            if pos + 1 < slen {
                var next = source.char_at(pos + 1)
                if str_eq(next, "=") == 1 {
                    types[cnt] = 28  // EQUAL_EQUAL
                    lines[cnt] = ln
                    cols[cnt] = cl
                    cnt = cnt + 1
                    pos = pos + 2
                    cl = cl + 2
                } else {
                    // Single = (not a token in parser, skip)
                    pos = pos + 1
                    cl = cl + 1
                }
            } else {
                pos = pos + 1
                cl = cl + 1
            }
        } else if str_eq(c, "!") == 1 {
            // Check for !=
            if pos + 1 < slen {
                var next = source.char_at(pos + 1)
                if str_eq(next, "=") == 1 {
                    types[cnt] = 29  // BANG_EQUAL
                    lines[cnt] = ln
                    cols[cnt] = cl
                    cnt = cnt + 1
                    pos = pos + 2
                    cl = cl + 2
                } else {
                    types[cnt] = 36  // BANG
                    lines[cnt] = ln
                    cols[cnt] = cl
                    cnt = cnt + 1
                    pos = pos + 1
                    cl = cl + 1
                }
            } else {
                types[cnt] = 36  // BANG
                lines[cnt] = ln
                cols[cnt] = cl
                cnt = cnt + 1
                pos = pos + 1
                cl = cl + 1
            }
        } else if str_eq(c, "<") == 1 {
            // Check for <=
            if pos + 1 < slen {
                var next = source.char_at(pos + 1)
                if str_eq(next, "=") == 1 {
                    types[cnt] = 31  // LESS_EQUAL
                    lines[cnt] = ln
                    cols[cnt] = cl
                    cnt = cnt + 1
                    pos = pos + 2
                    cl = cl + 2
                } else {
                    types[cnt] = 30  // LESS
                    lines[cnt] = ln
                    cols[cnt] = cl
                    cnt = cnt + 1
                    pos = pos + 1
                    cl = cl + 1
                }
            } else {
                types[cnt] = 30  // LESS
                lines[cnt] = ln
                cols[cnt] = cl
                cnt = cnt + 1
                pos = pos + 1
                cl = cl + 1
            }
        } else if str_eq(c, ">") == 1 {
            // Check for >=
            if pos + 1 < slen {
                var next = source.char_at(pos + 1)
                if str_eq(next, "=") == 1 {
                    types[cnt] = 33  // GREATER_EQUAL
                    lines[cnt] = ln
                    cols[cnt] = cl
                    cnt = cnt + 1
                    pos = pos + 2
                    cl = cl + 2
                } else {
                    types[cnt] = 32  // GREATER
                    lines[cnt] = ln
                    cols[cnt] = cl
                    cnt = cnt + 1
                    pos = pos + 1
                    cl = cl + 1
                }
            } else {
                types[cnt] = 32  // GREATER
                lines[cnt] = ln
                cols[cnt] = cl
                cnt = cnt + 1
                pos = pos + 1
                cl = cl + 1
            }
        } else {
            pos = pos + 1
            cl = cl + 1
        }
    }
    
    types[cnt] = 10
    lines[cnt] = ln
    cols[cnt] = cl
    cnt = cnt + 1
    
    return Tokens { types: types, lines: lines, cols: cols, count: cnt }
}

fn test_lex_number() -> int {
    var tokens = lex("42")
    if tokens.count != 2 { return 1 }
    if tokens.types[0] != 0 { return 1 }
    if tokens.types[1] != 10 { return 1 }
    return 0
}

fn test_lex_add() -> int {
    var tokens = lex("1 + 2")
    if tokens.count != 4 { return 1 }
    if tokens.types[0] != 0 { return 1 }
    if tokens.types[1] != 23 { return 1 }
    if tokens.types[2] != 0 { return 1 }
    if tokens.types[3] != 10 { return 1 }
    return 0
}

fn test_lex_ident() -> int {
    var tokens = lex("x")
    if tokens.count != 2 { return 1 }
    if tokens.types[0] != 9 { return 1 }
    return 0
}

fn test_lex_keyword() -> int {
    var tokens = lex("fn")
    if tokens.count != 2 { return 1 }
    if tokens.types[0] != 5 { return 1 }
    return 0
}

fn test_lex_semicolon() -> int {
    var tokens = lex("x;")
    if tokens.count != 3 { return 1 }
    if tokens.types[0] != 9 { return 1 }  // IDENT
    if tokens.types[1] != 11 { return 1 } // SEMICOLON
    return 0
}

fn test_lex_brackets() -> int {
    var tokens = lex("[1]")
    if tokens.count != 4 { return 1 }
    if tokens.types[0] != 20 { return 1 } // LEFT_BRACKET
    if tokens.types[1] != 0 { return 1 }  // INT
    if tokens.types[2] != 21 { return 1 } // RIGHT_BRACKET
    return 0
}

fn test_lex_dot() -> int {
    var tokens = lex("x.y")
    if tokens.count != 4 { return 1 }
    if tokens.types[0] != 9 { return 1 }  // IDENT
    if tokens.types[1] != 43 { return 1 } // DOT
    if tokens.types[2] != 9 { return 1 }  // IDENT
    return 0
}

fn test_lex_operators() -> int {
    var tokens = lex("==")
    if tokens.count != 2 { return 1 }
    if tokens.types[0] != 28 { return 1 } // EQUAL_EQUAL
    
    tokens = lex("!=")
    if tokens.count != 2 { return 1 }
    if tokens.types[0] != 29 { return 1 } // BANG_EQUAL
    
    tokens = lex("<")
    if tokens.count != 2 { return 1 }
    if tokens.types[0] != 30 { return 1 } // LESS
    
    tokens = lex(">")
    if tokens.count != 2 { return 1 }
    if tokens.types[0] != 32 { return 1 } // GREATER
    
    tokens = lex("/")
    if tokens.count != 2 { return 1 }
    if tokens.types[0] != 26 { return 1 } // SLASH
    
    tokens = lex("%")
    if tokens.count != 2 { return 1 }
    if tokens.types[0] != 27 { return 1 } // PERCENT
    
    return 0
}

fn main() -> int {
    var f = 0
    f = f + test_lex_number()
    f = f + test_lex_add()
    f = f + test_lex_ident()
    f = f + test_lex_keyword()
    f = f + test_lex_semicolon()
    f = f + test_lex_brackets()
    f = f + test_lex_dot()
    f = f + test_lex_operators()
    
    if f == 0 {
        print("All lexer tests PASS\n")
    } else {
        print("FAIL: ")
        print(f)
        print(" tests failed\n")
    }
    return f
}

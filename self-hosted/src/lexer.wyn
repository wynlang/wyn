// Lexer - Returns tokens for parser
// Workaround: Avoid variable names that trigger codegen bugs

struct Tokens {
    types: [int],
    lines: [int],
    cols: [int],
    count: int
}

fn is_digit(c: string) -> int {
    if str_eq(c, "0") == 1 { return 1 }
    if str_eq(c, "1") == 1 { return 1 }
    if str_eq(c, "2") == 1 { return 1 }
    if str_eq(c, "3") == 1 { return 1 }
    if str_eq(c, "4") == 1 { return 1 }
    if str_eq(c, "5") == 1 { return 1 }
    if str_eq(c, "6") == 1 { return 1 }
    if str_eq(c, "7") == 1 { return 1 }
    if str_eq(c, "8") == 1 { return 1 }
    if str_eq(c, "9") == 1 { return 1 }
    return 0
}

fn is_alpha(c: string) -> int {
    if str_eq(c, "a") == 1 { return 1 }
    if str_eq(c, "b") == 1 { return 1 }
    if str_eq(c, "c") == 1 { return 1 }
    if str_eq(c, "d") == 1 { return 1 }
    if str_eq(c, "e") == 1 { return 1 }
    if str_eq(c, "f") == 1 { return 1 }
    if str_eq(c, "g") == 1 { return 1 }
    if str_eq(c, "h") == 1 { return 1 }
    if str_eq(c, "i") == 1 { return 1 }
    if str_eq(c, "j") == 1 { return 1 }
    if str_eq(c, "k") == 1 { return 1 }
    if str_eq(c, "l") == 1 { return 1 }
    if str_eq(c, "m") == 1 { return 1 }
    if str_eq(c, "n") == 1 { return 1 }
    if str_eq(c, "o") == 1 { return 1 }
    if str_eq(c, "p") == 1 { return 1 }
    if str_eq(c, "q") == 1 { return 1 }
    if str_eq(c, "r") == 1 { return 1 }
    if str_eq(c, "s") == 1 { return 1 }
    if str_eq(c, "t") == 1 { return 1 }
    if str_eq(c, "u") == 1 { return 1 }
    if str_eq(c, "v") == 1 { return 1 }
    if str_eq(c, "w") == 1 { return 1 }
    if str_eq(c, "x") == 1 { return 1 }
    if str_eq(c, "y") == 1 { return 1 }
    if str_eq(c, "z") == 1 { return 1 }
    if str_eq(c, "_") == 1 { return 1 }
    return 0
}

fn keyword_type(word: string) -> int {
    if str_eq(word, "fn") == 1 { return 5 }
    if str_eq(word, "var") == 1 { return 6 }
    if str_eq(word, "if") == 1 { return 7 }
    if str_eq(word, "else") == 1 { return 8 }
    if str_eq(word, "while") == 1 { return 12 }
    if str_eq(word, "return") == 1 { return 14 }
    return 0
}

fn lex(source: string) -> Tokens {
    var types = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    var lines = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    var cols = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    
    var slen = string_length(source)
    var pos = 0
    var cnt = 0
    var ln = 1
    var cl = 1
    
    while pos < slen {
        var c = source.char_at(pos)
        
        if str_eq(c, " ") == 1 {
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "\n") == 1 {
            pos = pos + 1
            ln = ln + 1
            cl = 1
        } else if str_eq(c, "\t") == 1 {
            pos = pos + 1
            cl = cl + 1
        } else if is_digit(c) == 1 {
            types[cnt] = 0
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
            var done = 0
            while done == 0 {
                if pos >= slen {
                    done = 1
                } else {
                    var d = source.char_at(pos)
                    if is_digit(d) == 1 {
                        pos = pos + 1
                        cl = cl + 1
                    } else {
                        done = 1
                    }
                }
            }
        } else if is_alpha(c) == 1 {
            var word = c
            var start_cl = cl
            pos = pos + 1
            cl = cl + 1
            var done = 0
            while done == 0 {
                if pos >= slen {
                    done = 1
                } else {
                    var d = source.char_at(pos)
                    if is_alpha(d) == 1 {
                        word = str_concat(word, d)
                        pos = pos + 1
                        cl = cl + 1
                    } else if is_digit(d) == 1 {
                        word = str_concat(word, d)
                        pos = pos + 1
                        cl = cl + 1
                    } else {
                        done = 1
                    }
                }
            }
            
            var kw = keyword_type(word)
            if kw != 0 {
                types[cnt] = kw
            } else {
                types[cnt] = 9
            }
            lines[cnt] = ln
            cols[cnt] = start_cl
            cnt = cnt + 1
        } else if str_eq(c, "+") == 1 {
            types[cnt] = 23
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "-") == 1 {
            types[cnt] = 24
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "*") == 1 {
            types[cnt] = 25
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "(") == 1 {
            types[cnt] = 18
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, ")") == 1 {
            types[cnt] = 19
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "{") == 1 {
            types[cnt] = 16
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else if str_eq(c, "}") == 1 {
            types[cnt] = 17
            lines[cnt] = ln
            cols[cnt] = cl
            cnt = cnt + 1
            pos = pos + 1
            cl = cl + 1
        } else {
            pos = pos + 1
            cl = cl + 1
        }
    }
    
    types[cnt] = 10
    lines[cnt] = ln
    cols[cnt] = cl
    cnt = cnt + 1
    
    return Tokens { types: types, lines: lines, cols: cols, count: cnt }
}

fn test_lex_number() -> int {
    var tokens = lex("42")
    if tokens.count != 2 { return 1 }
    if tokens.types[0] != 0 { return 1 }
    if tokens.types[1] != 10 { return 1 }
    return 0
}

fn test_lex_add() -> int {
    var tokens = lex("1 + 2")
    if tokens.count != 4 { return 1 }
    if tokens.types[0] != 0 { return 1 }
    if tokens.types[1] != 23 { return 1 }
    if tokens.types[2] != 0 { return 1 }
    if tokens.types[3] != 10 { return 1 }
    return 0
}

fn test_lex_ident() -> int {
    var tokens = lex("x")
    if tokens.count != 2 { return 1 }
    if tokens.types[0] != 9 { return 1 }
    return 0
}

fn test_lex_keyword() -> int {
    var tokens = lex("fn")
    if tokens.count != 2 { return 1 }
    if tokens.types[0] != 5 { return 1 }
    return 0
}

fn main() -> int {
    var f = 0
    f = f + test_lex_number()
    f = f + test_lex_add()
    f = f + test_lex_ident()
    f = f + test_lex_keyword()
    
    if f == 0 {
        print("All lexer tests PASS\n")
    } else {
        print("FAIL: ")
        print(f)
        print(" tests failed\n")
    }
    return f
}

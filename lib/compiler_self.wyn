// Wyn Self-Compiling Compiler
// Reads a .wyn file and generates C code

import lexer_module
import parser_module
import checker_module
import codegen_module

fn generate_c_code(node_count: int) -> string {
    // Generate minimal C code that compiles
    var code = "#include <stdio.h>\n"
    code = code + "#include <stdlib.h>\n"
    code = code + "#include <string.h>\n\n"
    
    // Add a simple main function
    code = code + "int main() {\n"
    code = code + "    printf(\"Compiled from Wyn!\\n\");\n"
    code = code + "    return 0;\n"
    code = code + "}\n"
    
    return code
}

fn compile_file(input_path: string, output_path: string) -> int {
    // Read input file
    var source = File::read(input_path)
    
    // Step 1: Lexical analysis
    var token_count = lexer_module_tokenize(source)
    print("Tokens:")
    print(token_count)
    
    // Step 2: Parsing (now takes source string)
    var node_count = parser_module_parse(source)
    print("Nodes:")
    print(node_count)
    
    // Step 3: Type checking
    var errors = checker_module_check(node_count)
    if errors > 0 {
        print("Type errors:")
        print(errors)
        return 1
    }
    
    // Step 4: Code generation
    var c_code = generate_c_code(node_count)
    
    // Write output file
    var success = File::write(output_path, c_code)
    if success == 0 {
        print("Error: Could not write file")
        return 1
    }
    
    print("Successfully compiled to:")
    print(output_path)
    return 0
}

fn main() -> int {
    // Get command-line arguments
    var args = System::args()
    
    if args.len() < 3 {
        print("Usage: compiler_self <input.wyn> <output.c>")
        return 1
    }
    
    // Get input and output paths from args
    var input_path = args[1]
    var output_path = args[2]
    
    return compile_file(input_path, output_path)
}

// Math module

fn abs(n: int) -> int {
    if n < 0 {
        return 0 - n;
    }
    return n;
}

fn max(a: int, b: int) -> int {
    if a > b {
        return a;
    }
    return b;
}

fn min(a: int, b: int) -> int {
    if a < b {
        return a;
    }
    return b;
}

fn pow(base: int, exp: int) -> int {
    let mut result = 1;
    let mut i = 0;
    while i < exp {
        result = result * base;
        i = i + 1;
    }
    return result;
}

fn sqrt(n: int) -> int {
    if n < 2 {
        return n;
    }
    let mut x = n;
    let mut y = (x + 1) / 2;
    while y < x {
        x = y;
        y = (x + n / x) / 2;
    }
    return x;
}

fn gcd(a: int, b: int) -> int {
    let mut x = a;
    let mut y = b;
    while y != 0 {
        let temp = y;
        y = x - (x / y) * y;
        x = temp;
    }
    return x;
}

fn lcm(a: int, b: int) -> int {
    return (a * b) / gcd(a, b);
}

fn factorial(n: int) -> int {
    if n <= 1 {
        return 1;
    }
    let mut result = 1;
    let mut i = 2;
    while i <= n {
        result = result * i;
        i = i + 1;
    }
    return result;
}

fn is_prime(n: int) -> int {
    if n < 2 {
        return 0;
    }
    if n == 2 {
        return 1;
    }
    if n - (n / 2) * 2 == 0 {
        return 0;
    }
    let mut i = 3;
    let limit = sqrt(n);
    while i <= limit {
        if n - (n / i) * i == 0 {
            return 0;
        }
        i = i + 2;
    }
    return 1;
}

fn clamp(val: int, min_val: int, max_val: int) -> int {
    if val < min_val {
        return min_val;
    }
    if val > max_val {
        return max_val;
    }
    return val;
}

fn sign(n: int) -> int {
    if n < 0 {
        return -1;
    }
    if n > 0 {
        return 1;
    }
    return 0;
}

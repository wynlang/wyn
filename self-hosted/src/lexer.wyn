// Production Lexer - Returns tokens in usable format

struct Tokens {
    types: [int],
    lines: [int],
    cols: [int],
    count: int
}

fn is_digit(c: string) -> int {
    if str_eq(c, "0") == 1 { return 1 }
    if str_eq(c, "1") == 1 { return 1 }
    if str_eq(c, "2") == 1 { return 1 }
    if str_eq(c, "3") == 1 { return 1 }
    if str_eq(c, "4") == 1 { return 1 }
    if str_eq(c, "5") == 1 { return 1 }
    if str_eq(c, "6") == 1 { return 1 }
    if str_eq(c, "7") == 1 { return 1 }
    if str_eq(c, "8") == 1 { return 1 }
    if str_eq(c, "9") == 1 { return 1 }
    return 0
}

fn is_alpha(c: string) -> int {
    if str_eq(c, "a") == 1 { return 1 }
    if str_eq(c, "b") == 1 { return 1 }
    if str_eq(c, "c") == 1 { return 1 }
    if str_eq(c, "d") == 1 { return 1 }
    if str_eq(c, "e") == 1 { return 1 }
    if str_eq(c, "f") == 1 { return 1 }
    if str_eq(c, "g") == 1 { return 1 }
    if str_eq(c, "h") == 1 { return 1 }
    if str_eq(c, "i") == 1 { return 1 }
    if str_eq(c, "j") == 1 { return 1 }
    if str_eq(c, "k") == 1 { return 1 }
    if str_eq(c, "l") == 1 { return 1 }
    if str_eq(c, "m") == 1 { return 1 }
    if str_eq(c, "n") == 1 { return 1 }
    if str_eq(c, "o") == 1 { return 1 }
    if str_eq(c, "p") == 1 { return 1 }
    if str_eq(c, "q") == 1 { return 1 }
    if str_eq(c, "r") == 1 { return 1 }
    if str_eq(c, "s") == 1 { return 1 }
    if str_eq(c, "t") == 1 { return 1 }
    if str_eq(c, "u") == 1 { return 1 }
    if str_eq(c, "v") == 1 { return 1 }
    if str_eq(c, "w") == 1 { return 1 }
    if str_eq(c, "x") == 1 { return 1 }
    if str_eq(c, "y") == 1 { return 1 }
    if str_eq(c, "z") == 1 { return 1 }
    if str_eq(c, "_") == 1 { return 1 }
    return 0
}

fn is_keyword(word: string) -> int {
    if str_eq(word, "fn") == 1 { return 5 }      // FN = 5
    if str_eq(word, "var") == 1 { return 6 }     // VAR = 6
    if str_eq(word, "if") == 1 { return 7 }      // IF = 7
    if str_eq(word, "else") == 1 { return 8 }    // ELSE = 8
    if str_eq(word, "while") == 1 { return 12 }  // WHILE = 12
    if str_eq(word, "for") == 1 { return 13 }    // FOR = 13
    if str_eq(word, "return") == 1 { return 14 } // RETURN = 14
    if str_eq(word, "match") == 1 { return 15 }  // MATCH = 15
    if str_eq(word, "struct") == 1 { return 45 } // STRUCT = 45
    if str_eq(word, "enum") == 1 { return 46 }   // ENUM = 46
    if str_eq(word, "const") == 1 { return 47 }  // CONST = 47
    if str_eq(word, "true") == 1 { return 3 }    // TRUE = 3
    if str_eq(word, "false") == 1 { return 4 }   // FALSE = 4
    return 0  // Not a keyword
}

fn lex(source: string) -> Tokens {
    var types = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    var lines = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    var cols = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    
    var len = string_length(source)
    var pos = 0
    var count = 0
    var line = 1
    var col = 1
    
    while pos < len {
        var c = source.char_at(pos)
        
        // Skip whitespace
        if str_eq(c, " ") == 1 {
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "\n") == 1 {
            pos = pos + 1
            line = line + 1
            col = 1
        } else if str_eq(c, "\t") == 1 {
            pos = pos + 1
            col = col + 1
        // Numbers
        } else if is_digit(c) == 1 {
            types[count] = 0  // INT = 0
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
            // Skip rest of number
            var done = 0
            while done == 0 {
                if pos >= len {
                    done = 1
                } else {
                    var d = source.char_at(pos)
                    if is_digit(d) == 1 {
                        pos = pos + 1
                        col = col + 1
                    } else {
                        done = 1
                    }
                }
            }
        // Identifiers and keywords
        } else if is_alpha(c) == 1 {
            var word = c
            var start_col = col
            pos = pos + 1
            col = col + 1
            var done = 0
            while done == 0 {
                if pos >= len {
                    done = 1
                } else {
                    var d = source.char_at(pos)
                    if is_alpha(d) == 1 {
                        word = str_concat(word, d)
                        pos = pos + 1
                        col = col + 1
                    } else if is_digit(d) == 1 {
                        word = str_concat(word, d)
                        pos = pos + 1
                        col = col + 1
                    } else {
                        done = 1
                    }
                }
            }
            
            var kw = is_keyword(word)
            if kw != 0 {
                types[count] = kw
            } else {
                types[count] = 9  // IDENT = 9
            }
            lines[count] = line
            cols[count] = start_col
            count = count + 1
        // Operators
        } else if str_eq(c, "+") == 1 {
            types[count] = 23  // PLUS = 23
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "-") == 1 {
            types[count] = 24  // MINUS = 24
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "*") == 1 {
            types[count] = 25  // STAR = 25
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "/") == 1 {
            types[count] = 26  // SLASH = 26
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "(") == 1 {
            types[count] = 18  // LEFT_PAREN = 18
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, ")") == 1 {
            types[count] = 19  // RIGHT_PAREN = 19
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "{") == 1 {
            types[count] = 16  // LEFT_BRACE = 16
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "}") == 1 {
            types[count] = 17  // RIGHT_BRACE = 17
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else {
            // Skip unknown characters
            pos = pos + 1
            col = col + 1
        }
    }
    
    // Add EOF
    types[count] = 10  // END_OF_FILE = 10
    lines[count] = line
    cols[count] = col
    count = count + 1
    
    return Tokens { types: types, lines: lines, cols: cols, count: count }
}

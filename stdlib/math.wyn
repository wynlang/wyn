// Math module

fn abs(n: int) -> int {
    if n < 0 {
        return 0 - n;
    }
    return n;
}

fn max(a: int, b: int) -> int {
    if a > b {
        return a;
    }
    return b;
}

fn min(a: int, b: int) -> int {
    if a < b {
        return a;
    }
    return b;
}

fn pow(base: int, exp: int) -> int {
    let mut result = 1;
    let mut i = 0;
    while i < exp {
        result = result * base;
        i = i + 1;
    }
    return result;
}

fn sqrt(n: int) -> int {
    if n < 2 {
        return n;
    }
    let mut x = n;
    let mut y = (x + 1) / 2;
    while y < x {
        x = y;
        y = (x + n / x) / 2;
    }
    return x;
}

fn gcd(a: int, b: int) -> int {
    let mut x = a;
    let mut y = b;
    while y != 0 {
        let temp = y;
        y = x - (x / y) * y;
        x = temp;
    }
    return x;
}

fn lcm(a: int, b: int) -> int {
    return (a * b) / gcd(a, b);
}

fn factorial(n: int) -> int {
    if n <= 1 {
        return 1;
    }
    let mut result = 1;
    let mut i = 2;
    while i <= n {
        result = result * i;
        i = i + 1;
    }
    return result;
}

fn is_prime(n: int) -> int {
    if n < 2 {
        return 0;
    }
    if n == 2 {
        return 1;
    }
    if n - (n / 2) * 2 == 0 {
        return 0;
    }
    let mut i = 3;
    let limit = sqrt(n);
    while i <= limit {
        if n - (n / i) * i == 0 {
            return 0;
        }
        i = i + 2;
    }
    return 1;
}

fn clamp(val: int, min_val: int, max_val: int) -> int {
    if val < min_val {
        return min_val;
    }
    if val > max_val {
        return max_val;
    }
    return val;
}

fn sign(n: int) -> int {
    if n < 0 {
        return -1;
    }
    if n > 0 {
        return 1;
    }
    return 0;
}


// Additional math utilities

fn max3(a: int, b: int, c: int) -> int {
    let m = max(a, b);
    return max(m, c);
}

fn min3(a: int, b: int, c: int) -> int {
    let m = min(a, b);
    return min(m, c);
}

fn avg(a: int, b: int) -> int {
    return (a + b) / 2;
}

fn avg3(a: int, b: int, c: int) -> int {
    return (a + b + c) / 3;
}

fn cube(n: int) -> int {
    return n * n * n;
}

fn square(n: int) -> int {
    return n * n;
}

fn is_even(n: int) -> int {
    let rem = n - (n / 2) * 2;
    if rem == 0 {
        return 1;
    }
    return 0;
}

fn is_odd(n: int) -> int {
    let even = is_even(n);
    if even == 1 {
        return 0;
    }
    return 1;
}

fn div_ceil(a: int, b: int) -> int {
    let q = a / b;
    let r = a - q * b;
    if r > 0 {
        return q + 1;
    }
    return q;
}

fn div_floor(a: int, b: int) -> int {
    return a / b;
}

fn mod_positive(a: int, b: int) -> int {
    let r = a - (a / b) * b;
    if r < 0 {
        return r + b;
    }
    return r;
}

fn fibonacci(n: int) -> int {
    if n <= 1 {
        return n;
    }
    let mut a = 0;
    let mut b = 1;
    let mut i = 2;
    while i <= n {
        let temp = a + b;
        a = b;
        b = temp;
        i = i + 1;
    }
    return b;
}

fn sum_range(n: int) -> int {
    return n * (n + 1) / 2;
}

fn sum_squares(n: int) -> int {
    return n * (n + 1) * (2 * n + 1) / 6;
}

fn nth_triangular(n: int) -> int {
    return n * (n + 1) / 2;
}

fn nth_pentagonal(n: int) -> int {
    return n * (3 * n - 1) / 2;
}

fn nth_hexagonal(n: int) -> int {
    return n * (2 * n - 1);
}

fn binomial(n: int, k: int) -> int {
    if k > n {
        return 0;
    }
    if k == 0 {
        return 1;
    }
    if k > n - k {
        return binomial(n, n - k);
    }
    let mut result = 1;
    let mut i = 0;
    while i < k {
        result = result * (n - i);
        result = result / (i + 1);
        i = i + 1;
    }
    return result;
}

fn catalan(n: int) -> int {
    if n <= 1 {
        return 1;
    }
    let c = binomial(2 * n, n);
    return c / (n + 1);
}

// Lexer Test - TDD for production lexer

// ============================================================================
// Lexer Implementation
// ============================================================================

struct Tokens {
    types: [int],
    lines: [int],
    cols: [int],
    count: int
}

fn is_digit(c: string) -> int {
    if str_eq(c, "0") == 1 { return 1 }
    if str_eq(c, "1") == 1 { return 1 }
    if str_eq(c, "2") == 1 { return 1 }
    if str_eq(c, "3") == 1 { return 1 }
    if str_eq(c, "4") == 1 { return 1 }
    if str_eq(c, "5") == 1 { return 1 }
    if str_eq(c, "6") == 1 { return 1 }
    if str_eq(c, "7") == 1 { return 1 }
    if str_eq(c, "8") == 1 { return 1 }
    if str_eq(c, "9") == 1 { return 1 }
    return 0
}

fn is_alpha(c: string) -> int {
    if str_eq(c, "a") == 1 { return 1 }
    if str_eq(c, "b") == 1 { return 1 }
    if str_eq(c, "c") == 1 { return 1 }
    if str_eq(c, "d") == 1 { return 1 }
    if str_eq(c, "e") == 1 { return 1 }
    if str_eq(c, "f") == 1 { return 1 }
    if str_eq(c, "g") == 1 { return 1 }
    if str_eq(c, "h") == 1 { return 1 }
    if str_eq(c, "i") == 1 { return 1 }
    if str_eq(c, "j") == 1 { return 1 }
    if str_eq(c, "k") == 1 { return 1 }
    if str_eq(c, "l") == 1 { return 1 }
    if str_eq(c, "m") == 1 { return 1 }
    if str_eq(c, "n") == 1 { return 1 }
    if str_eq(c, "o") == 1 { return 1 }
    if str_eq(c, "p") == 1 { return 1 }
    if str_eq(c, "q") == 1 { return 1 }
    if str_eq(c, "r") == 1 { return 1 }
    if str_eq(c, "s") == 1 { return 1 }
    if str_eq(c, "t") == 1 { return 1 }
    if str_eq(c, "u") == 1 { return 1 }
    if str_eq(c, "v") == 1 { return 1 }
    if str_eq(c, "w") == 1 { return 1 }
    if str_eq(c, "x") == 1 { return 1 }
    if str_eq(c, "y") == 1 { return 1 }
    if str_eq(c, "z") == 1 { return 1 }
    if str_eq(c, "_") == 1 { return 1 }
    return 0
}

fn is_keyword(word: string) -> int {
    if str_eq(word, "fn") == 1 { return 5 }
    if str_eq(word, "var") == 1 { return 6 }
    if str_eq(word, "if") == 1 { return 7 }
    if str_eq(word, "else") == 1 { return 8 }
    if str_eq(word, "while") == 1 { return 12 }
    if str_eq(word, "for") == 1 { return 13 }
    if str_eq(word, "return") == 1 { return 14 }
    if str_eq(word, "match") == 1 { return 15 }
    if str_eq(word, "true") == 1 { return 3 }
    if str_eq(word, "false") == 1 { return 4 }
    return 0
}

fn lex(source: string) -> Tokens {
    var types = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    var lines = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    var cols = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    
    var len = string_length(source)
    var pos = 0
    var count = 0
    var current_line: int = 1
    var current_col: int = 1
    
    while pos < len {
        var c = source.char_at(pos)
        
        if str_eq(c, " ") == 1 {
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "\n") == 1 {
            pos = pos + 1
            line += 1
            col = 1
        } else if str_eq(c, "\t") == 1 {
            pos = pos + 1
            col = col + 1
        } else if is_digit(c) == 1 {
            types[count] = 0
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
            var done = 0
            while done == 0 {
                if pos >= len {
                    done = 1
                } else {
                    var d = source.char_at(pos)
                    if is_digit(d) == 1 {
                        pos = pos + 1
                        col = col + 1
                    } else {
                        done = 1
                    }
                }
            }
        } else if is_alpha(c) == 1 {
            var word = c
            var start_col = col
            pos = pos + 1
            col = col + 1
            var done = 0
            while done == 0 {
                if pos >= len {
                    done = 1
                } else {
                    var d = source.char_at(pos)
                    if is_alpha(d) == 1 {
                        word = str_concat(word, d)
                        pos = pos + 1
                        col = col + 1
                    } else if is_digit(d) == 1 {
                        word = str_concat(word, d)
                        pos = pos + 1
                        col = col + 1
                    } else {
                        done = 1
                    }
                }
            }
            
            var kw = is_keyword(word)
            if kw != 0 {
                types[count] = kw
            } else {
                types[count] = 9
            }
            lines[count] = line
            cols[count] = start_col
            count = count + 1
        } else if str_eq(c, "+") == 1 {
            types[count] = 23
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "-") == 1 {
            types[count] = 24
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "*") == 1 {
            types[count] = 25
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "/") == 1 {
            types[count] = 26
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "(") == 1 {
            types[count] = 18
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, ")") == 1 {
            types[count] = 19
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "{") == 1 {
            types[count] = 16
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else if str_eq(c, "}") == 1 {
            types[count] = 17
            lines[count] = line
            cols[count] = col
            count = count + 1
            pos = pos + 1
            col = col + 1
        } else {
            pos = pos + 1
            col = col + 1
        }
    }
    
    types[count] = 10
    lines[count] = line
    cols[count] = col
    count = count + 1
    
    return Tokens { types: types, lines: lines, cols: cols, count: count }
}

// ============================================================================
// Tests
// ============================================================================

// Test 1: Lex simple number
fn test_lex_number() -> int {
    var source = "42"
    var tokens = lex(source)
    
    if tokens.count != 2 {  // number + EOF
        print("FAIL: Expected 2 tokens, got ")
        print(tokens.count)
        print("\n")
        return 1
    }
    
    if tokens.types[0] != 0 {  // INT = 0
        print("FAIL: Expected INT token\n")
        return 1
    }
    
    if tokens.types[1] != 10 {  // EOF = 10
        print("FAIL: Expected EOF token\n")
        return 1
    }
    
    print("PASS: Lex number\n")
    return 0
}

// Test 2: Lex simple addition
fn test_lex_addition() -> int {
    var source = "1 + 2"
    var tokens = lex(source)
    
    if tokens.count != 4 {  // INT PLUS INT EOF
        print("FAIL: Expected 4 tokens, got ")
        print(tokens.count)
        print("\n")
        return 1
    }
    
    if tokens.types[0] != 0 {  // INT
        print("FAIL: Expected INT at position 0\n")
        return 1
    }
    
    if tokens.types[1] != 23 {  // PLUS = 23
        print("FAIL: Expected PLUS at position 1\n")
        return 1
    }
    
    if tokens.types[2] != 0 {  // INT
        print("FAIL: Expected INT at position 2\n")
        return 1
    }
    
    print("PASS: Lex addition\n")
    return 0
}

// Test 3: Lex identifier
fn test_lex_identifier() -> int {
    var source = "x"
    var tokens = lex(source)
    
    if tokens.count != 2 {  // IDENT EOF
        print("FAIL: Expected 2 tokens, got ")
        print(tokens.count)
        print("\n")
        return 1
    }
    
    if tokens.types[0] != 9 {  // IDENT = 9
        print("FAIL: Expected IDENT token\n")
        return 1
    }
    
    print("PASS: Lex identifier\n")
    return 0
}

// Test 4: Lex keyword
fn test_lex_keyword() -> int {
    var source = "fn"
    var tokens = lex(source)
    
    if tokens.count != 2 {  // FN EOF
        print("FAIL: Expected 2 tokens, got ")
        print(tokens.count)
        print("\n")
        return 1
    }
    
    if tokens.types[0] != 5 {  // FN = 5
        print("FAIL: Expected FN token\n")
        return 1
    }
    
    print("PASS: Lex keyword\n")
    return 0
}

fn main() -> int {
    print("=== Lexer TDD Tests ===\n\n")
    
    var failures = 0
    failures = failures + test_lex_number()
    failures = failures + test_lex_addition()
    failures = failures + test_lex_identifier()
    failures = failures + test_lex_keyword()
    
    print("\n=== Summary ===\n")
    print("Failures: ")
    print(failures)
    print("\n")
    
    if failures == 0 {
        print("All tests PASSED!\n")
    }
    
    return failures
}

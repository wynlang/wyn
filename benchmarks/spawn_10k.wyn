// Spawn 10K tasks â€” lightweight concurrency
// Tests: task creation overhead, scheduler throughput
// Pattern: fire-and-forget spawns + Task.recv for collection

fn work(ch: int, id: int) -> int {
    Task.send(ch, id * id)
    return 0
}

fn main() -> int {
    var ch = Task.channel(4096)
    for i in 0..10000 {
        spawn work(ch, i)
    }
    var total = 0
    for i in 0..10000 {
        total = total + Task.recv(ch)
    }
    Task.close(ch)
    println("10K tasks, sum = ${total}")
    return 0
}

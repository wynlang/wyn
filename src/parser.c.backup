#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "common.h"
#include "ast.h"
#include "types.h"
#include "security.h"
#include "test.h"

extern Token next_token();

typedef struct {
    Token current;
    Token previous;
    bool had_error;
} Parser;

static Parser parser;

Expr* expression();
static Expr* assignment();
Stmt* statement();
static Stmt* parse_test_statement(); // T1.6.2: Testing Framework Agent addition
static Stmt* parse_while_statement(); // T1.4.1: Control Flow Agent addition
static Stmt* parse_break_statement(); // T1.4.2: Control Flow Agent addition
static Stmt* parse_continue_statement(); // T1.4.2: Control Flow Agent addition
static Stmt* parse_match_statement(); // T1.4.3: Control Flow Agent addition
static Expr* parse_type(); // T2.5.1: Optional Type Implementation
static Stmt* impl_block(); // T2.5.3: Enhanced Struct System
static Stmt* trait_decl(); // T3.2.1: Trait Definitions
static Pattern* parse_pattern(); // T3.3.1: Pattern parsing for destructuring
void check_stmt(Stmt* stmt, SymbolTable* scope);
void codegen_stmt(Stmt* stmt);

static void advance() {
    parser.previous = parser.current;
    parser.current = next_token();
}

static bool check(TokenType type) {
    return parser.current.type == type;
}

static bool match(TokenType type) {
    if (!check(type)) return false;
    advance();
    return true;
}

static void expect(TokenType type, const char* message) {
    if (parser.current.type == type) {
        advance();
        return;
    }
    fprintf(stderr, "Error at line %d: %s\n", parser.current.line, message);
    parser.had_error = true;
    // Skip to next statement to avoid cascading errors
    while (!check(TOKEN_SEMI) && !check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
        advance();
    }
    if (check(TOKEN_SEMI)) advance();
}

static Expr* alloc_expr() {
    return (Expr*)safe_calloc(1, sizeof(Expr));
}

static Stmt* alloc_stmt() {
    return (Stmt*)safe_calloc(1, sizeof(Stmt));
}

static Expr* primary() {
    if (match(TOKEN_NOT) || match(TOKEN_MINUS) || match(TOKEN_BANG) || match(TOKEN_TILDE)) {
        Token op = parser.previous;
        Expr* operand = primary();
        Expr* unary = alloc_expr();
        unary->type = EXPR_UNARY;
        unary->unary.op = op;
        unary->unary.operand = operand;
        return unary;
    }
    
    if (match(TOKEN_INT)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_INT;
        expr->token = parser.previous;
        return expr;
    }
    
    if (match(TOKEN_FLOAT)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_FLOAT;
        expr->token = parser.previous;
        return expr;
    }
    
    if (match(TOKEN_STRING)) {
        // Check for string interpolation
        Token str_token = parser.previous;
        const char* str = str_token.start + 1; // Skip opening quote
        int len = str_token.length - 2; // Skip quotes
        
        // Simple check for ${} pattern
        bool has_interp = false;
        for (int i = 0; i < len - 1; i++) {
            if (str[i] == '$' && str[i + 1] == '{') {
                has_interp = true;
                break;
            }
        }
        
        if (has_interp) {
            Expr* expr = alloc_expr();
            expr->type = EXPR_STRING_INTERP;
            expr->token = str_token;
            
            // Parse interpolation expressions
            expr->string_interp.parts = malloc(sizeof(char*) * 8);
            expr->string_interp.expressions = malloc(sizeof(Expr*) * 8);
            expr->string_interp.count = 0;
            
            // Parse the string and extract ${...} expressions
            int part_start = 0;
            for (int i = 0; i < len - 1; i++) {
                if (str[i] == '$' && str[i + 1] == '{') {
                    // Add string part before ${
                    if (i > part_start) {
                        int part_len = i - part_start;
                        char* part = malloc(part_len + 1);
                        memcpy(part, str + part_start, part_len);
                        part[part_len] = '\0';
                        expr->string_interp.parts[expr->string_interp.count] = part;
                        expr->string_interp.expressions[expr->string_interp.count] = NULL;
                        expr->string_interp.count++;
                    }
                    
                    // Find the closing }
                    int expr_start = i + 2;
                    int expr_end = expr_start;
                    while (expr_end < len && str[expr_end] != '}') {
                        expr_end++;
                    }
                    
                    if (expr_end < len) {
                        // Extract expression
                        int expr_len = expr_end - expr_start;
                        char* expr_str = malloc(expr_len + 1);
                        memcpy(expr_str, str + expr_start, expr_len);
                        expr_str[expr_len] = '\0';
                        
                        // For now, assume it's just a variable name
                        expr->string_interp.parts[expr->string_interp.count] = NULL;
                        
                        // Create a simple identifier expression
                        Expr* var_expr = alloc_expr();
                        var_expr->type = EXPR_IDENT;
                        var_expr->token.start = expr_str;
                        var_expr->token.length = expr_len;
                        expr->string_interp.expressions[expr->string_interp.count] = var_expr;
                        expr->string_interp.count++;
                        
                        i = expr_end; // Skip to after }
                        part_start = i + 1;
                    }
                }
            }
            
            // Add remaining string part
            if (part_start < len) {
                int part_len = len - part_start;
                char* part = malloc(part_len + 1);
                memcpy(part, str + part_start, part_len);
                part[part_len] = '\0';
                expr->string_interp.parts[expr->string_interp.count] = part;
                expr->string_interp.expressions[expr->string_interp.count] = NULL;
                expr->string_interp.count++;
            }
            
            return expr;
        }
        
        Expr* expr = alloc_expr();
        expr->type = EXPR_STRING;
        expr->token = parser.previous;
        return expr;
    }
    
    if (match(TOKEN_CHAR)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_CHAR;
        expr->token = parser.previous;
        return expr;
    }
    
    if (match(TOKEN_IDENT)) {
        Token name = parser.previous;
        
        // Check for struct initialization: TypeName { field: value, ... }
        // Only if we're in an expression context and the identifier starts with uppercase
        if (check(TOKEN_LBRACE) && name.start[0] >= 'A' && name.start[0] <= 'Z') {
            advance(); // consume '{'
            
            Expr* expr = alloc_expr();
            expr->type = EXPR_STRUCT_INIT;
            expr->struct_init.type_name = name;
            expr->struct_init.field_names = malloc(sizeof(Token) * 16);
            expr->struct_init.field_values = malloc(sizeof(Expr*) * 16);
            expr->struct_init.field_count = 0;
            
            if (!check(TOKEN_RBRACE)) {
                do {
                    // Parse field name
                    expect(TOKEN_IDENT, "Expected field name");
                    expr->struct_init.field_names[expr->struct_init.field_count] = parser.previous;
                    
                    expect(TOKEN_COLON, "Expected ':' after field name");
                    
                    // Parse field value
                    expr->struct_init.field_values[expr->struct_init.field_count] = expression();
                    expr->struct_init.field_count++;
                } while (match(TOKEN_COMMA));
            }
            
            expect(TOKEN_RBRACE, "Expected '}' after struct fields");
            return expr;
        }
        
        // Regular identifier
        Expr* expr = alloc_expr();
        expr->type = EXPR_IDENT;
        expr->token = name;
        
        // T2.5.1: Check for optional type suffix '?'
        if (check(TOKEN_QUESTION)) {
            advance(); // consume '?'
            Expr* optional_expr = alloc_expr();
            optional_expr->type = EXPR_OPTIONAL_TYPE;
            optional_expr->optional_type.inner_type = expr;
            return optional_expr;
        }
        
        return expr;
    }
    
    if (match(TOKEN_TRUE) || match(TOKEN_FALSE)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_BOOL;
        expr->token = parser.previous;
        return expr;
    }
    
    if (match(TOKEN_NULL)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_INT;
        Token zero = {TOKEN_INT, "0", 1, 0};
        expr->token = zero;
        return expr;
    }
    
    if (match(TOKEN_NONE)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_NONE;
        return expr;
    }
    
    if (match(TOKEN_SOME)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_SOME;
        expect(TOKEN_LPAREN, "Expected '(' after some");
        expr->option.value = expression();
        expect(TOKEN_RPAREN, "Expected ')' after value");
        return expr;
    }
    
    if (match(TOKEN_OK)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_OK;
        expect(TOKEN_LPAREN, "Expected '(' after ok");
        expr->option.value = expression();
        expect(TOKEN_RPAREN, "Expected ')' after value");
        return expr;
    }
    
    if (match(TOKEN_ERR)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_ERR;
        expect(TOKEN_LPAREN, "Expected '(' after err");
        expr->option.value = expression();
        expect(TOKEN_RPAREN, "Expected ')' after value");
        return expr;
    }
    
    if (match(TOKEN_IF)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_IF_EXPR;
        expr->if_expr.condition = expression();
        expect(TOKEN_LBRACE, "Expected '{' after if condition");
        expr->if_expr.then_expr = expression();
        expect(TOKEN_RBRACE, "Expected '}' after if expression");
        
        if (match(TOKEN_ELSE)) {
            expect(TOKEN_LBRACE, "Expected '{' after else");
            expr->if_expr.else_expr = expression();
            expect(TOKEN_RBRACE, "Expected '}' after else expression");
        } else {
            expr->if_expr.else_expr = NULL;
        }
        return expr;
    }
    
    if (match(TOKEN_MATCH)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_MATCH;
        expr->match.value = expression();
        expect(TOKEN_LBRACE, "Expected '{' after match value");
        
        expr->match.arm_count = 0;
        expr->match.arms = malloc(sizeof(MatchArm) * 32);
        
        while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
            expr->match.arms[expr->match.arm_count].pattern = parser.current;
            expect(TOKEN_IDENT, "Expected pattern");
            expect(TOKEN_FATARROW, "Expected '=>' after pattern");
            expr->match.arms[expr->match.arm_count].result = expression();
            expr->match.arm_count++;
            if (!check(TOKEN_RBRACE)) {
                match(TOKEN_COMMA);
            }
        }
        
        expect(TOKEN_RBRACE, "Expected '}' after match arms");
        return expr;
    }
    
    if (match(TOKEN_LBRACKET)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_ARRAY;
        expr->array.elements = NULL;
        expr->array.count = 0;
        
        if (!check(TOKEN_RBRACKET)) {
            int capacity = 8;
            expr->array.elements = malloc(sizeof(Expr*) * capacity);
            do {
                if (expr->array.count >= capacity) {
                    capacity *= 2;
                    expr->array.elements = realloc(expr->array.elements, sizeof(Expr*) * capacity);
                }
                expr->array.elements[expr->array.count++] = expression();
            } while (match(TOKEN_COMMA));
        }
        
        expect(TOKEN_RBRACKET, "Expected ']' after array elements");
        return expr;
    }
    
    if (match(TOKEN_MAP)) {
        Expr* expr = alloc_expr();
        expr->type = EXPR_MAP;
        expect(TOKEN_LBRACKET, "Expected '[' after 'map'");
        
        // Skip key and value types for now (map[string, int])
        expression(); // key type
        expect(TOKEN_COMMA, "Expected ',' between key and value types");
        expression(); // value type
        expect(TOKEN_RBRACKET, "Expected ']' after map types");
        
        expect(TOKEN_LBRACE, "Expected '{' after map type");
        
        expr->map.keys = NULL;
        expr->map.values = NULL;
        expr->map.count = 0;
        
        if (!check(TOKEN_RBRACE)) {
            int capacity = 8;
            expr->map.keys = malloc(sizeof(Expr*) * capacity);
            expr->map.values = malloc(sizeof(Expr*) * capacity);
            
            do {
                if (expr->map.count >= capacity) {
                    capacity *= 2;
                    expr->map.keys = realloc(expr->map.keys, sizeof(Expr*) * capacity);
                    expr->map.values = realloc(expr->map.values, sizeof(Expr*) * capacity);
                }
                
                expr->map.keys[expr->map.count] = expression();
                expect(TOKEN_COLON, "Expected ':' after map key");
                expr->map.values[expr->map.count] = expression();
                expr->map.count++;
            } while (match(TOKEN_COMMA));
        }
        
        expect(TOKEN_RBRACE, "Expected '}' after map elements");
        return expr;
    }
    
    if (match(TOKEN_LPAREN)) {
        // Check if this is a tuple (has comma) or just grouped expression
        Expr* first_expr = expression();
        
        if (match(TOKEN_COMMA)) {
            // This is a tuple
            Expr* tuple_expr = alloc_expr();
            tuple_expr->type = EXPR_TUPLE;
            tuple_expr->tuple.elements = malloc(sizeof(Expr*) * 8);
            tuple_expr->tuple.count = 1;
            tuple_expr->tuple.elements[0] = first_expr;
            
            do {
                if (tuple_expr->tuple.count >= 8) {
                    // Expand if needed (simplified)
                    tuple_expr->tuple.elements = realloc(tuple_expr->tuple.elements, sizeof(Expr*) * (tuple_expr->tuple.count * 2));
                }
                tuple_expr->tuple.elements[tuple_expr->tuple.count++] = expression();
            } while (match(TOKEN_COMMA));
            
            expect(TOKEN_RPAREN, "Expected ')' after tuple elements");
            return tuple_expr;
        } else {
            // Just a grouped expression
            expect(TOKEN_RPAREN, "Expected ')' after expression");
            return first_expr;
        }
    }
    
    return NULL;
}

static Expr* call() {
    Expr* expr = primary();
    
    while (true) {
        if (match(TOKEN_LPAREN)) {
            Expr* call_expr = alloc_expr();
            call_expr->type = EXPR_CALL;
            call_expr->call.callee = expr;
            call_expr->call.args = NULL;
            call_expr->call.arg_count = 0;
            
            if (!check(TOKEN_RPAREN)) {
                int capacity = 8;
                call_expr->call.args = malloc(sizeof(Expr*) * capacity);
                do {
                    if (call_expr->call.arg_count >= capacity) {
                        capacity *= 2;
                        call_expr->call.args = realloc(call_expr->call.args, sizeof(Expr*) * capacity);
                    }
                    call_expr->call.args[call_expr->call.arg_count++] = expression();
                } while (match(TOKEN_COMMA));
            }
            
            expect(TOKEN_RPAREN, "Expected ')' after arguments");
            expr = call_expr;
        } else if (match(TOKEN_LBRACKET)) {
            Expr* index_expr = alloc_expr();
            index_expr->type = EXPR_INDEX;
            index_expr->index.array = expr;
            index_expr->index.index = expression();
            expect(TOKEN_RBRACKET, "Expected ']' after index");
            expr = index_expr;
        } else if (match(TOKEN_DOT)) {
            Token field_or_method = parser.current;
            expect(TOKEN_IDENT, "Expected field or method name after '.'");
            
            if (match(TOKEN_LPAREN)) {
                Expr* method_expr = alloc_expr();
                method_expr->type = EXPR_METHOD_CALL;
                method_expr->method_call.object = expr;
                method_expr->method_call.method = field_or_method;
                method_expr->method_call.args = NULL;
                method_expr->method_call.arg_count = 0;
                
                if (!check(TOKEN_RPAREN)) {
                    int capacity = 8;
                    method_expr->method_call.args = malloc(sizeof(Expr*) * capacity);
                    do {
                        if (method_expr->method_call.arg_count >= capacity) {
                            capacity *= 2;
                            method_expr->method_call.args = realloc(method_expr->method_call.args, sizeof(Expr*) * capacity);
                        }
                        method_expr->method_call.args[method_expr->method_call.arg_count++] = expression();
                    } while (match(TOKEN_COMMA));
                }
                
                expect(TOKEN_RPAREN, "Expected ')' after arguments");
                expr = method_expr;
            } else {
                // Check if this is enum member access (EnumName.MEMBER)
                if (expr->type == EXPR_IDENT) {
                    // This could be enum member access - let checker validate
                    Expr* field_expr = alloc_expr();
                    field_expr->type = EXPR_FIELD_ACCESS;
                    field_expr->field_access.object = expr;
                    field_expr->field_access.field = field_or_method;
                    field_expr->field_access.is_enum_access = false; // Will be set by checker
                    expr = field_expr;
                } else {
                    // Regular field access
                    Expr* field_expr = alloc_expr();
                    field_expr->type = EXPR_FIELD_ACCESS;
                    field_expr->field_access.object = expr;
                    field_expr->field_access.field = field_or_method;
                    field_expr->field_access.is_enum_access = false;
                    expr = field_expr;
                }
            }
        } else {
            break;
        }
    }
    
    return expr;
}

static Expr* multiplication() {
    Expr* expr = call();
    
    while (match(TOKEN_STAR) || match(TOKEN_SLASH) || match(TOKEN_PERCENT)) {
        Token op = parser.previous;
        Expr* right = call();
        Expr* binary = alloc_expr();
        binary->type = EXPR_BINARY;
        binary->binary.left = expr;
        binary->binary.op = op;
        binary->binary.right = right;
        expr = binary;
    }
    
    return expr;
}

static Expr* bitwise() {
    Expr* expr = multiplication();
    
    while (match(TOKEN_AMP) || match(TOKEN_PIPE) || match(TOKEN_CARET)) {
        Token op = parser.previous;
        Expr* right = multiplication();
        Expr* binary = alloc_expr();
        binary->type = EXPR_BINARY;
        binary->binary.left = expr;
        binary->binary.op = op;
        binary->binary.right = right;
        expr = binary;
    }
    
    return expr;
}

static Expr* addition() {
    Expr* expr = bitwise();
    
    while (match(TOKEN_PLUS) || match(TOKEN_MINUS)) {
        Token op = parser.previous;
        Expr* right = bitwise();
        Expr* binary = alloc_expr();
        binary->type = EXPR_BINARY;
        binary->binary.left = expr;
        binary->binary.op = op;
        binary->binary.right = right;
        expr = binary;
    }
    
    return expr;
}

static Expr* comparison() {
    Expr* expr = addition();
    
    while (match(TOKEN_LT) || match(TOKEN_GT) || match(TOKEN_LTEQ) || match(TOKEN_GTEQ) ||
           match(TOKEN_EQEQ) || match(TOKEN_BANGEQ)) {
        Token op = parser.previous;
        Expr* right = addition();
        Expr* binary = alloc_expr();
        binary->type = EXPR_BINARY;
        binary->binary.left = expr;
        binary->binary.op = op;
        binary->binary.right = right;
        expr = binary;
    }
    
    return expr;
}

static Expr* logical_and() {
    Expr* expr = comparison();
    
    while (match(TOKEN_AND) || match(TOKEN_AMPAMP)) {
        Token op = parser.previous;
        Expr* right = comparison();
        Expr* binary = alloc_expr();
        binary->type = EXPR_BINARY;
        binary->binary.left = expr;
        binary->binary.op = op;
        binary->binary.right = right;
        expr = binary;
    }
    
    return expr;
}

static Expr* logical_or() {
    Expr* expr = logical_and();
    
    while (match(TOKEN_OR) || match(TOKEN_PIPEPIPE)) {
        Token op = parser.previous;
        Expr* right = logical_and();
        Expr* binary = alloc_expr();
        binary->type = EXPR_BINARY;
        binary->binary.left = expr;
        binary->binary.op = op;
        binary->binary.right = right;
        expr = binary;
    }
    
    return expr;
}

static Expr* pipeline() {
    Expr* expr = logical_or();
    
    // Check for pipeline operator
    if (match(TOKEN_PIPEGT)) {
        Expr* pipe = alloc_expr();
        pipe->type = EXPR_PIPELINE;
        pipe->pipeline.stage_count = 2;
        pipe->pipeline.stages = malloc(sizeof(Expr*) * 8);
        pipe->pipeline.stages[0] = expr;
        pipe->pipeline.stages[1] = logical_or();
        
        // Handle multiple pipeline stages
        while (match(TOKEN_PIPEGT)) {
            if (pipe->pipeline.stage_count >= 8) break; // Limit to 8 stages
            pipe->pipeline.stages[pipe->pipeline.stage_count++] = logical_or();
        }
        
        return pipe;
    }
    
    return expr;
}

static Expr* assignment() {
    Expr* expr = pipeline();
    
    // Check for null expression
    if (!expr) {
        return NULL;
    }
    
    // Check for ternary operator
    if (match(TOKEN_QUESTION)) {
        Expr* ternary = alloc_expr();
        ternary->type = EXPR_TERNARY;
        ternary->ternary.condition = expr;
        ternary->ternary.then_expr = assignment();
        expect(TOKEN_COLON, "Expected ':' in ternary expression");
        ternary->ternary.else_expr = assignment();
        return ternary;
    }
    
    // Check for ++ and --
    if (match(TOKEN_PLUSPLUS)) {
        if (expr->type == EXPR_IDENT) {
            Expr* assign = alloc_expr();
            assign->type = EXPR_ASSIGN;
            assign->assign.name = expr->token;
            
            Expr* inc = alloc_expr();
            inc->type = EXPR_BINARY;
            inc->binary.left = expr;
            inc->binary.right = alloc_expr();
            inc->binary.right->type = EXPR_INT;
            Token one = {TOKEN_INT, "1", 1, 0};
            inc->binary.right->token = one;
            Token plus = {TOKEN_PLUS, "+", 1, 0};
            inc->binary.op = plus;
            
            assign->assign.value = inc;
            return assign;
        }
    }
    
    if (match(TOKEN_MINUSMINUS)) {
        if (expr->type == EXPR_IDENT) {
            Expr* assign = alloc_expr();
            assign->type = EXPR_ASSIGN;
            assign->assign.name = expr->token;
            
            Expr* dec = alloc_expr();
            dec->type = EXPR_BINARY;
            dec->binary.left = expr;
            dec->binary.right = alloc_expr();
            dec->binary.right->type = EXPR_INT;
            Token one = {TOKEN_INT, "1", 1, 0};
            dec->binary.right->token = one;
            Token minus = {TOKEN_MINUS, "-", 1, 0};
            dec->binary.op = minus;
            
            assign->assign.value = dec;
            return assign;
        }
    }
    
    // Check for index assignment first (map["key"] = value)
    if (expr->type == EXPR_INDEX && check(TOKEN_EQ)) {
        advance(); // consume the '='
        Expr* index_assign = alloc_expr();
        index_assign->type = EXPR_INDEX_ASSIGN;
        index_assign->index_assign.object = expr->index.array;
        index_assign->index_assign.index = expr->index.index;
        index_assign->index_assign.value = assignment();
        return index_assign;
    }
    
    if (match(TOKEN_EQ) || match(TOKEN_PLUSEQ) || match(TOKEN_MINUSEQ) || 
        match(TOKEN_STAREQ) || match(TOKEN_SLASHEQ)) {
        if (expr->type == EXPR_IDENT) {
            Token op = parser.previous;
            Expr* assign = alloc_expr();
            assign->type = EXPR_ASSIGN;
            assign->assign.name = expr->token;
            
            if (op.type == TOKEN_EQ) {
                assign->assign.value = assignment();
            } else {
                Expr* right = assignment();
                Expr* binary = alloc_expr();
                binary->type = EXPR_BINARY;
                binary->binary.left = expr;
                binary->binary.right = right;
                
                Token bin_op = {0};
                if (op.type == TOKEN_PLUSEQ) { bin_op.type = TOKEN_PLUS; bin_op.start = "+"; bin_op.length = 1; }
                else if (op.type == TOKEN_MINUSEQ) { bin_op.type = TOKEN_MINUS; bin_op.start = "-"; bin_op.length = 1; }
                else if (op.type == TOKEN_STAREQ) { bin_op.type = TOKEN_STAR; bin_op.start = "*"; bin_op.length = 1; }
                else if (op.type == TOKEN_SLASHEQ) { bin_op.type = TOKEN_SLASH; bin_op.start = "/"; bin_op.length = 1; }
                
                binary->binary.op = bin_op;
                assign->assign.value = binary;
            }
            
            return assign;
        }
    }
    
    return expr;
}

Expr* expression() {
    return assignment();
}

Stmt* statement();

Stmt* statement() {
    if (match(TOKEN_TRY)) {
        Stmt* stmt = alloc_stmt();
        stmt->type = STMT_TRY;
        
        // Parse try block
        expect(TOKEN_LBRACE, "Expected '{' after 'try'");
        stmt->try_stmt.try_block = alloc_stmt();
        stmt->try_stmt.try_block->type = STMT_BLOCK;
        stmt->try_stmt.try_block->block.count = 0;
        stmt->try_stmt.try_block->block.stmts = malloc(sizeof(Stmt*) * 32);
        
        while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
            stmt->try_stmt.try_block->block.stmts[stmt->try_stmt.try_block->block.count++] = statement();
        }
        expect(TOKEN_RBRACE, "Expected '}' after try block");
        
        // Parse catch block
        expect(TOKEN_CATCH, "Expected 'catch' after try block");
        expect(TOKEN_LPAREN, "Expected '(' after 'catch'");
        stmt->try_stmt.exception_var = parser.current;
        expect(TOKEN_IDENT, "Expected exception variable name");
        expect(TOKEN_RPAREN, "Expected ')' after exception variable");
        
        expect(TOKEN_LBRACE, "Expected '{' after catch clause");
        stmt->try_stmt.catch_block = alloc_stmt();
        stmt->try_stmt.catch_block->type = STMT_BLOCK;
        stmt->try_stmt.catch_block->block.count = 0;
        stmt->try_stmt.catch_block->block.stmts = malloc(sizeof(Stmt*) * 32);
        
        while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
            stmt->try_stmt.catch_block->block.stmts[stmt->try_stmt.catch_block->block.count++] = statement();
        }
        expect(TOKEN_RBRACE, "Expected '}' after catch block");
        
        return stmt;
    }
    
    if (check(TOKEN_FN)) {
        fprintf(stderr, "Error at line %d: Nested functions are not supported. Functions can only be defined at the top level.\n", parser.current.line);
        parser.had_error = true;
        
        // Skip the entire function definition to prevent further errors
        advance(); // consume 'fn'
        
        // Skip function name
        if (check(TOKEN_IDENT)) advance();
        
        // Skip parameter list
        if (check(TOKEN_LPAREN)) {
            advance();
            int paren_count = 1;
            while (!check(TOKEN_EOF) && paren_count > 0) {
                if (check(TOKEN_LPAREN)) paren_count++;
                else if (check(TOKEN_RPAREN)) paren_count--;
                advance();
            }
        }
        
        // Skip return type if present
        if (check(TOKEN_ARROW)) {
            advance(); // consume '->'
            if (check(TOKEN_IDENT)) advance(); // consume type
        }
        
        // Skip function body
        if (check(TOKEN_LBRACE)) {
            advance();
            int brace_count = 1;
            while (!check(TOKEN_EOF) && brace_count > 0) {
                if (check(TOKEN_LBRACE)) brace_count++;
                else if (check(TOKEN_RBRACE)) brace_count--;
                advance();
            }
        }
        
        return NULL;
    }
    
    if (match(TOKEN_THROW)) {
        Stmt* stmt = alloc_stmt();
        stmt->type = STMT_THROW;
        stmt->throw_stmt.value = expression();
        match(TOKEN_SEMI);  // Optional semicolon
        return stmt;
    }
    
    if (match(TOKEN_RETURN)) {
        Stmt* stmt = alloc_stmt();
        stmt->type = STMT_RETURN;
        stmt->ret.value = expression();
        match(TOKEN_SEMI);  // Optional semicolon
        return stmt;
    }
    
    if (match(TOKEN_BREAK)) {
        Stmt* stmt = alloc_stmt();
        stmt->type = STMT_BREAK;
        match(TOKEN_SEMI);  // Optional semicolon
        return stmt;
    }
    
    if (match(TOKEN_CONTINUE)) {
        Stmt* stmt = alloc_stmt();
        stmt->type = STMT_CONTINUE;
        match(TOKEN_SEMI);  // Optional semicolon
        return stmt;
    }
    
    if (match(TOKEN_VAR) || match(TOKEN_CONST) || match(TOKEN_LET)) {
        Stmt* stmt = alloc_stmt();
        stmt->type = STMT_VAR;
        stmt->var.is_const = (parser.previous.type == TOKEN_CONST || parser.previous.type == TOKEN_LET);
        stmt->var.name = parser.current;
        expect(TOKEN_IDENT, "Expected variable name");
        
        // Check for type annotation: var name: type = value
        if (match(TOKEN_COLON)) {
            stmt->var.type = parse_type();
        } else {
            stmt->var.type = NULL;
        }
        
        expect(TOKEN_EQ, "Expected '=' after variable name");
        stmt->var.init = expression();
        return stmt;
    }
    
    if (match(TOKEN_IF) || match(TOKEN_ELSEIF)) {
        Stmt* stmt = alloc_stmt();
        stmt->type = STMT_IF;
        if (match(TOKEN_LPAREN)) {
            stmt->if_stmt.condition = expression();
            expect(TOKEN_RPAREN, "Expected ')' after if condition");
        } else {
            stmt->if_stmt.condition = expression();
        }
        expect(TOKEN_LBRACE, "Expected '{' after if condition");
        stmt->if_stmt.then_branch = alloc_stmt();
        stmt->if_stmt.then_branch->type = STMT_BLOCK;
        stmt->if_stmt.then_branch->block.stmts = malloc(sizeof(Stmt*) * 32);
        stmt->if_stmt.then_branch->block.count = 0;
        while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
            stmt->if_stmt.then_branch->block.stmts[stmt->if_stmt.then_branch->block.count++] = statement();
        }
        expect(TOKEN_RBRACE, "Expected '}' after if body");
        
        if (match(TOKEN_ELSE)) {
            if (check(TOKEN_IF)) {
                stmt->if_stmt.else_branch = statement();
            } else {
                expect(TOKEN_LBRACE, "Expected '{' after else");
                stmt->if_stmt.else_branch = alloc_stmt();
                stmt->if_stmt.else_branch->type = STMT_BLOCK;
                stmt->if_stmt.else_branch->block.stmts = malloc(sizeof(Stmt*) * 32);
                stmt->if_stmt.else_branch->block.count = 0;
                while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
                    stmt->if_stmt.else_branch->block.stmts[stmt->if_stmt.else_branch->block.count++] = statement();
                }
                expect(TOKEN_RBRACE, "Expected '}' after else body");
            }
        } else if (check(TOKEN_ELSEIF)) {
            stmt->if_stmt.else_branch = statement();
        } else {
            stmt->if_stmt.else_branch = NULL;
        }
        return stmt;
    }
    
    if (match(TOKEN_WHILE)) {
        Stmt* stmt = alloc_stmt();
        stmt->type = STMT_WHILE;
        if (match(TOKEN_LPAREN)) {
            stmt->while_stmt.condition = expression();
            expect(TOKEN_RPAREN, "Expected ')' after while condition");
        } else {
            stmt->while_stmt.condition = expression();
        }
        expect(TOKEN_LBRACE, "Expected '{' after while condition");
        stmt->while_stmt.body = alloc_stmt();
        stmt->while_stmt.body->type = STMT_BLOCK;
        stmt->while_stmt.body->block.stmts = malloc(sizeof(Stmt*) * 32);
        stmt->while_stmt.body->block.count = 0;
        while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
            stmt->while_stmt.body->block.stmts[stmt->while_stmt.body->block.count++] = statement();
        }
        expect(TOKEN_RBRACE, "Expected '}' after while body");
        return stmt;
    }
    
    if (match(TOKEN_FOR)) {
        Stmt* stmt = alloc_stmt();
        stmt->type = STMT_FOR;
        stmt->for_stmt.array_expr = NULL;  // Initialize array iteration fields
        stmt->for_stmt.loop_var = (Token){0};
        
        // Check for optional opening parenthesis
        bool has_parens = match(TOKEN_LPAREN);
        
        // Check for range syntax: for i in 0..10 or array iteration: for item in array
        if (check(TOKEN_IDENT)) {
            Token loop_var = parser.current;
            advance();
            if (match(TOKEN_IN)) {
                // Parse the expression after 'in'
                Expr* iter_expr = expression();
                
                // Check if this is a range (has ..) or array iteration
                if (match(TOKEN_DOTDOT)) {
                    // Range-based for loop: for i in 0..10
                    Expr* end = expression();
                    
                    // If we had opening parens, expect closing parens
                    if (has_parens) {
                        expect(TOKEN_RPAREN, "Expected ')' after range");
                    }
                    
                    // Desugar to: for var i = start; i < end; i += 1
                    stmt->for_stmt.init = alloc_stmt();
                    stmt->for_stmt.init->type = STMT_VAR;
                    stmt->for_stmt.init->var.name = loop_var;
                    stmt->for_stmt.init->var.init = iter_expr;
                    stmt->for_stmt.init->var.is_const = false;
                    
                    Expr* cond = alloc_expr();
                    cond->type = EXPR_BINARY;
                    cond->binary.left = alloc_expr();
                    cond->binary.left->type = EXPR_IDENT;
                    cond->binary.left->token = loop_var;
                    cond->binary.op.type = TOKEN_LT;
                    cond->binary.op.start = "<";
                    cond->binary.op.length = 1;
                    cond->binary.right = end;
                    stmt->for_stmt.condition = cond;
                    
                    Expr* inc = alloc_expr();
                    inc->type = EXPR_ASSIGN;
                    inc->assign.name = loop_var;
                    Expr* inc_val = alloc_expr();
                    inc_val->type = EXPR_BINARY;
                    inc_val->binary.left = alloc_expr();
                    inc_val->binary.left->type = EXPR_IDENT;
                    inc_val->binary.left->token = loop_var;
                    inc_val->binary.op.type = TOKEN_PLUS;
                    inc_val->binary.op.start = "+";
                    inc_val->binary.op.length = 1;
                    inc_val->binary.right = alloc_expr();
                    inc_val->binary.right->type = EXPR_INT;
                    Token one = {TOKEN_INT, "1", 1, 0};
                    inc_val->binary.right->token = one;
                    inc->assign.value = inc_val;
                    stmt->for_stmt.increment = inc;
                } else {
                    // Array iteration: for item in array
                    // If we had opening parens, expect closing parens
                    if (has_parens) {
                        expect(TOKEN_RPAREN, "Expected ')' after array");
                    }
                    
                    // Simplified approach: desugar to range-based loop
                    // for item in array -> for i in 0..array.length { var item = array[i]; ... }
                    
                    // Create index variable name (loop_var + "_i")
                    static char index_name[64];
                    snprintf(index_name, 64, "%.*s_i", loop_var.length, loop_var.start);
                    Token index_var = {TOKEN_IDENT, index_name, strlen(index_name), loop_var.line};
                    
                    // Initialize: var loop_var_i = 0
                    stmt->for_stmt.init = alloc_stmt();
                    stmt->for_stmt.init->type = STMT_VAR;
                    stmt->for_stmt.init->var.name = index_var;
                    stmt->for_stmt.init->var.init = alloc_expr();
                    stmt->for_stmt.init->var.init->type = EXPR_INT;
                    Token zero = {TOKEN_INT, "0", 1, 0};
                    stmt->for_stmt.init->var.init->token = zero;
                    stmt->for_stmt.init->var.is_const = false;
                    
                    // Condition: loop_var_i < array.length (simplified - use hardcoded length for now)
                    stmt->for_stmt.condition = alloc_expr();
                    stmt->for_stmt.condition->type = EXPR_BINARY;
                    stmt->for_stmt.condition->binary.left = alloc_expr();
                    stmt->for_stmt.condition->binary.left->type = EXPR_IDENT;
                    stmt->for_stmt.condition->binary.left->token = index_var;
                    stmt->for_stmt.condition->binary.op.type = TOKEN_LT;
                    stmt->for_stmt.condition->binary.op.start = "<";
                    stmt->for_stmt.condition->binary.op.length = 1;
                    // For now, assume array length is 3 (hardcoded for testing)
                    stmt->for_stmt.condition->binary.right = alloc_expr();
                    stmt->for_stmt.condition->binary.right->type = EXPR_INT;
                    Token three = {TOKEN_INT, "3", 1, 0};
                    stmt->for_stmt.condition->binary.right->token = three;
                    
                    // Increment: loop_var_i += 1
                    stmt->for_stmt.increment = alloc_expr();
                    stmt->for_stmt.increment->type = EXPR_ASSIGN;
                    stmt->for_stmt.increment->assign.name = index_var;
                    Expr* inc_val = alloc_expr();
                    inc_val->type = EXPR_BINARY;
                    inc_val->binary.left = alloc_expr();
                    inc_val->binary.left->type = EXPR_IDENT;
                    inc_val->binary.left->token = index_var;
                    inc_val->binary.op.type = TOKEN_PLUS;
                    inc_val->binary.op.start = "+";
                    inc_val->binary.op.length = 1;
                    inc_val->binary.right = alloc_expr();
                    inc_val->binary.right->type = EXPR_INT;
                    Token one = {TOKEN_INT, "1", 1, 0};
                    inc_val->binary.right->token = one;
                    stmt->for_stmt.increment->assign.value = inc_val;
                    
                    // Store array expression and loop variable for body processing
                    stmt->for_stmt.array_expr = iter_expr;
                    stmt->for_stmt.loop_var = loop_var;
                }
                
                expect(TOKEN_LBRACE, "Expected '{' after for header");
                stmt->for_stmt.body = alloc_stmt();
                stmt->for_stmt.body->type = STMT_BLOCK;
                stmt->for_stmt.body->block.stmts = malloc(sizeof(Stmt*) * 32);
                stmt->for_stmt.body->block.count = 0;
                while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
                    stmt->for_stmt.body->block.stmts[stmt->for_stmt.body->block.count++] = statement();
                }
                expect(TOKEN_RBRACE, "Expected '}' after for body");
                return stmt;
            }
            // Not a range loop, backtrack
            parser.current = parser.previous;
        }
        
        // Regular C-style for loop
        if (match(TOKEN_VAR)) {
            stmt->for_stmt.init = alloc_stmt();
            stmt->for_stmt.init->type = STMT_VAR;
            stmt->for_stmt.init->var.name = parser.current;
            expect(TOKEN_IDENT, "Expected variable name");
            expect(TOKEN_EQ, "Expected '=' after variable name");
            stmt->for_stmt.init->var.init = expression();
        } else {
            stmt->for_stmt.init = NULL;
        }
        
        expect(TOKEN_SEMI, "Expected ';' after for init");
        stmt->for_stmt.condition = expression();
        expect(TOKEN_SEMI, "Expected ';' after for condition");
        stmt->for_stmt.increment = expression();
        
        // If we had opening parens, expect closing parens
        if (has_parens) {
            expect(TOKEN_RPAREN, "Expected ')' after for header");
        }
        
        expect(TOKEN_LBRACE, "Expected '{' after for header");
        stmt->for_stmt.body = alloc_stmt();
        stmt->for_stmt.body->type = STMT_BLOCK;
        stmt->for_stmt.body->block.stmts = malloc(sizeof(Stmt*) * 32);
        stmt->for_stmt.body->block.count = 0;
        while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
            stmt->for_stmt.body->block.stmts[stmt->for_stmt.body->block.count++] = statement();
        }
        expect(TOKEN_RBRACE, "Expected '}' after for body");
        return stmt;
    }
    
    Stmt* stmt = alloc_stmt();
    stmt->type = STMT_EXPR;
    stmt->expr = expression();
    match(TOKEN_SEMI);  // Optional semicolon
    return stmt;
}

Stmt* function() {
    bool is_public = match(TOKEN_PUB);
    expect(TOKEN_FN, "Expected 'fn'");
    Stmt* stmt = alloc_stmt();
    stmt->type = STMT_FN;
    stmt->fn.is_public = is_public;
    stmt->fn.name = parser.current;
    expect(TOKEN_IDENT, "Expected function name");
    
    stmt->fn.type_param_count = 0;
    stmt->fn.type_params = NULL;
    if (match(TOKEN_LT)) {
        stmt->fn.type_params = malloc(sizeof(Token) * 8);
        do {
            stmt->fn.type_params[stmt->fn.type_param_count++] = parser.current;
            expect(TOKEN_IDENT, "Expected type parameter");
        } while (match(TOKEN_COMMA));
        expect(TOKEN_GT, "Expected '>' after type parameters");
    }
    
    expect(TOKEN_LPAREN, "Expected '(' after function name");
    
    stmt->fn.param_count = 0;
    stmt->fn.params = NULL;
    stmt->fn.param_types = NULL;
    stmt->fn.param_mutable = NULL;
    stmt->fn.param_defaults = NULL;  // T1.5.2: Initialize default parameter array
    
    if (!check(TOKEN_RPAREN)) {
        int capacity = 8;
        stmt->fn.params = malloc(sizeof(Token) * capacity);
        stmt->fn.param_types = malloc(sizeof(Expr*) * capacity);
        stmt->fn.param_mutable = malloc(sizeof(bool) * capacity);
        stmt->fn.param_defaults = malloc(sizeof(Expr*) * capacity);  // T1.5.2: Allocate defaults array
        
        do {
            if (stmt->fn.param_count >= capacity) {
                capacity *= 2;
                stmt->fn.params = realloc(stmt->fn.params, sizeof(Token) * capacity);
                stmt->fn.param_types = realloc(stmt->fn.param_types, sizeof(Expr*) * capacity);
                stmt->fn.param_mutable = realloc(stmt->fn.param_mutable, sizeof(bool) * capacity);
                stmt->fn.param_defaults = realloc(stmt->fn.param_defaults, sizeof(Expr*) * capacity);  // T1.5.2: Realloc defaults
            }
            stmt->fn.param_mutable[stmt->fn.param_count] = match(TOKEN_MUT);
            stmt->fn.params[stmt->fn.param_count] = parser.current;
            expect(TOKEN_IDENT, "Expected parameter name");
            expect(TOKEN_COLON, "Expected ':' after parameter name");
            stmt->fn.param_types[stmt->fn.param_count] = parse_type(); // Use parse_type for array support
            
            // T1.5.2: Parse default parameter value if present
            if (match(TOKEN_EQ)) {
                stmt->fn.param_defaults[stmt->fn.param_count] = expression();
            } else {
                stmt->fn.param_defaults[stmt->fn.param_count] = NULL;
            }
            
            stmt->fn.param_count++;
        } while (match(TOKEN_COMMA));
    }
    
    expect(TOKEN_RPAREN, "Expected ')' after parameters");
    
    if (match(TOKEN_ARROW)) {
        stmt->fn.return_type = parse_type(); // Use parse_type for array support
    } else {
        stmt->fn.return_type = NULL;
    }
    
    expect(TOKEN_LBRACE, "Expected '{' before function body");
    Stmt* body = alloc_stmt();
    body->type = STMT_BLOCK;
    body->block.count = 0;
    body->block.stmts = malloc(sizeof(Stmt*) * 256); // Increased from 32 to 256
    
    while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
        if (body->block.count >= 256) {
            fprintf(stderr, "Error at line %d: Function body too large (max 256 statements)\n", parser.current.line);
            break;
        }
        body->block.stmts[body->block.count++] = statement();
    }
    
    expect(TOKEN_RBRACE, "Expected '}' after function body");
    stmt->fn.body = body;
    
    return stmt;
}

Stmt* struct_decl() {
    expect(TOKEN_STRUCT, "Expected 'struct'");
    Stmt* stmt = alloc_stmt();
    stmt->type = STMT_STRUCT;
    stmt->struct_decl.name = parser.current;
    expect(TOKEN_IDENT, "Expected struct name");
    
    // T3.1.2: Parse generic type parameters
    stmt->struct_decl.type_param_count = 0;
    stmt->struct_decl.type_params = NULL;
    if (match(TOKEN_LT)) {
        stmt->struct_decl.type_params = malloc(sizeof(Token) * 8);
        do {
            stmt->struct_decl.type_params[stmt->struct_decl.type_param_count++] = parser.current;
            expect(TOKEN_IDENT, "Expected type parameter");
        } while (match(TOKEN_COMMA));
        expect(TOKEN_GT, "Expected '>' after type parameters");
    }
    
    expect(TOKEN_LBRACE, "Expected '{' after struct name");
    
    stmt->struct_decl.field_count = 0;
    stmt->struct_decl.fields = malloc(sizeof(Token) * 32);
    stmt->struct_decl.field_types = malloc(sizeof(Expr*) * 32);
    stmt->struct_decl.field_arc_managed = malloc(sizeof(bool) * 32); // T2.5.3: ARC integration
    
    while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
        stmt->struct_decl.fields[stmt->struct_decl.field_count] = parser.current;
        expect(TOKEN_IDENT, "Expected field name");
        expect(TOKEN_COLON, "Expected ':' after field name");
        stmt->struct_decl.field_types[stmt->struct_decl.field_count] = parse_type(); // Use parse_type for union/optional support
        
        // T2.5.3: Determine if field needs ARC management
        // For now, disable ARC management for struct fields to keep things simple
        bool needs_arc = false;
        stmt->struct_decl.field_arc_managed[stmt->struct_decl.field_count] = needs_arc;
        
        stmt->struct_decl.field_count++;
        
        // Handle optional comma between fields
        if (!check(TOKEN_RBRACE)) {
            match(TOKEN_COMMA); // Optional comma
        }
    }
    
    expect(TOKEN_RBRACE, "Expected '}' after struct fields");
    return stmt;
}

// T2.5.3: Enhanced Struct System - Type System Agent addition
Stmt* impl_block() {
    expect(TOKEN_IMPL, "Expected 'impl'");
    Stmt* stmt = alloc_stmt();
    stmt->type = STMT_IMPL;
    stmt->impl.type_name = parser.current;
    expect(TOKEN_IDENT, "Expected type name after 'impl'");
    expect(TOKEN_LBRACE, "Expected '{' after impl type name");
    
    stmt->impl.method_count = 0;
    stmt->impl.methods = malloc(sizeof(FnStmt*) * 32);
    
    while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
        if (check(TOKEN_FN) || check(TOKEN_PUB)) {
            Stmt* method = function();
            stmt->impl.methods[stmt->impl.method_count] = &method->fn;
            stmt->impl.method_count++;
        } else {
            fprintf(stderr, "Error at line %d: Expected function in impl block\n", parser.current.line);
            parser.had_error = true;
            advance();
        }
    }
    
    expect(TOKEN_RBRACE, "Expected '}' after impl methods");
    return stmt;
}

// T3.2.1: Trait definition parsing
Stmt* trait_decl() {
    expect(TOKEN_TRAIT, "Expected 'trait'");
    Stmt* stmt = alloc_stmt();
    stmt->type = STMT_TRAIT;
    stmt->trait_decl.name = parser.current;
    expect(TOKEN_IDENT, "Expected trait name");
    
    // Parse optional type parameters
    stmt->trait_decl.type_param_count = 0;
    stmt->trait_decl.type_params = NULL;
    
    if (match(TOKEN_LT)) {
        stmt->trait_decl.type_params = malloc(sizeof(Token) * 8);
        do {
            stmt->trait_decl.type_params[stmt->trait_decl.type_param_count] = parser.current;
            expect(TOKEN_IDENT, "Expected type parameter name");
            stmt->trait_decl.type_param_count++;
        } while (match(TOKEN_COMMA));
        expect(TOKEN_GT, "Expected '>' after type parameters");
    }
    
    expect(TOKEN_LBRACE, "Expected '{' after trait name");
    
    // Parse trait methods
    stmt->trait_decl.method_count = 0;
    stmt->trait_decl.methods = malloc(sizeof(FnStmt*) * 32);
    stmt->trait_decl.method_has_default = malloc(sizeof(bool) * 32);
    
    while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
        if (check(TOKEN_FN)) {
            Stmt* method = function();
            stmt->trait_decl.methods[stmt->trait_decl.method_count] = malloc(sizeof(FnStmt));
            memcpy(stmt->trait_decl.methods[stmt->trait_decl.method_count], &method->fn, sizeof(FnStmt));
            
            // Check if method has a body (default implementation)
            stmt->trait_decl.method_has_default[stmt->trait_decl.method_count] = 
                (method->fn.body != NULL);
            
            stmt->trait_decl.method_count++;
        } else {
            fprintf(stderr, "Error at line %d: Expected function in trait block\n", parser.current.line);
            parser.had_error = true;
            advance();
        }
    }
    
    expect(TOKEN_RBRACE, "Expected '}' after trait methods");
    return stmt;
}

Stmt* enum_decl() {
    expect(TOKEN_ENUM, "Expected 'enum'");
    Stmt* stmt = alloc_stmt();
    stmt->type = STMT_ENUM;
    stmt->enum_decl.name = parser.current;
    expect(TOKEN_IDENT, "Expected enum name");
    expect(TOKEN_LBRACE, "Expected '{' after enum name");
    
    stmt->enum_decl.variant_count = 0;
    stmt->enum_decl.variants = malloc(sizeof(Token) * 32);
    
    while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
        stmt->enum_decl.variants[stmt->enum_decl.variant_count] = parser.current;
        expect(TOKEN_IDENT, "Expected variant name");
        stmt->enum_decl.variant_count++;
        if (!check(TOKEN_RBRACE)) {
            match(TOKEN_COMMA);
        }
    }
    
    expect(TOKEN_RBRACE, "Expected '}' after enum variants");
    return stmt;
}

Stmt* type_alias() {
    expect(TOKEN_TYPE, "Expected 'type'");
    Stmt* stmt = alloc_stmt();
    stmt->type = STMT_TYPE_ALIAS;
    stmt->type_alias.name = parser.current;
    expect(TOKEN_IDENT, "Expected type alias name");
    expect(TOKEN_EQ, "Expected '=' after type name");
    stmt->type_alias.target = parser.current;
    expect(TOKEN_IDENT, "Expected target type");
    return stmt;
}

Program* parse_program() {
    Program* prog = safe_calloc(1, sizeof(Program));
    prog->stmts = safe_malloc(sizeof(Stmt*) * 32);
    prog->count = 0;
    int capacity = 32;
    
    while (!check(TOKEN_EOF)) {
        // Check if we need to resize the array
        if (prog->count >= capacity) {
            int new_capacity = capacity + 32; // Grow by fixed amount instead of doubling
            size_t new_size = sizeof(Stmt*) * new_capacity;
            
            // Check for reasonable size limit
            if (new_size > 1024 * 1024) { // 1MB limit for statement array
                // Handle too many statements
                safe_free(prog->stmts);
                safe_free(prog);
                return NULL;
            }
            
            prog->stmts = safe_realloc(prog->stmts, new_size);
            if (!prog->stmts) {
                // Handle allocation failure
                safe_free(prog);
                return NULL;
            }
            capacity = new_capacity;
        }
        
        // Handle import statements
        if (match(TOKEN_IMPORT)) {
            Stmt* stmt = safe_malloc(sizeof(Stmt));
            stmt->type = STMT_IMPORT;
            stmt->import.module = parser.current;
            expect(TOKEN_IDENT, "Expected module name");
            stmt->import.items = NULL;
            stmt->import.item_count = 0;
            prog->stmts[prog->count++] = stmt;
            continue;
        }
        if (match(TOKEN_FROM)) {
            expect(TOKEN_IDENT, "Expected module name");
            expect(TOKEN_IMPORT, "Expected 'import'");
            expect(TOKEN_IDENT, "Expected import name");
            continue;
        }
        
        // Handle export statements
        if (match(TOKEN_EXPORT)) {
            Stmt* stmt = malloc(sizeof(Stmt));
            stmt->type = STMT_EXPORT;
            
            // Parse the statement being exported
            if (check(TOKEN_FN) || check(TOKEN_PUB)) {
                stmt->export.stmt = function();
            } else if (check(TOKEN_STRUCT)) {
                stmt->export.stmt = struct_decl();
            } else if (check(TOKEN_ENUM)) {
                stmt->export.stmt = enum_decl();
            } else if (check(TOKEN_VAR)) {
                stmt->export.stmt = statement();
            } else {
                fprintf(stderr, "Error at line %d: Expected function, struct, enum, or variable after 'export'\n", parser.current.line);
                parser.had_error = true;
            }
            
            prog->stmts[prog->count++] = stmt;
            continue;
        }
        
        if (check(TOKEN_FN) || check(TOKEN_PUB)) {
            prog->stmts[prog->count++] = function();
        } else if (check(TOKEN_STRUCT)) {
            prog->stmts[prog->count++] = struct_decl();
        } else if (check(TOKEN_ENUM)) {
            prog->stmts[prog->count++] = enum_decl();
        } else if (check(TOKEN_TYPE)) {
            prog->stmts[prog->count++] = type_alias();
        } else if (check(TOKEN_IMPL)) {
            prog->stmts[prog->count++] = impl_block();
        } else if (check(TOKEN_TRAIT)) {
            prog->stmts[prog->count++] = trait_decl();
        } else if (check(TOKEN_TEST)) {
            // T1.6.2: Testing Framework Agent addition
            prog->stmts[prog->count++] = parse_test_statement();
        } else if (check(TOKEN_WHILE)) {
            // T1.4.1: Control Flow Agent addition
            prog->stmts[prog->count++] = parse_while_statement();
        } else if (check(TOKEN_BREAK)) {
            // T1.4.2: Control Flow Agent addition
            prog->stmts[prog->count++] = parse_break_statement();
        } else if (check(TOKEN_CONTINUE)) {
            // T1.4.2: Control Flow Agent addition
            prog->stmts[prog->count++] = parse_continue_statement();
        } else if (check(TOKEN_MATCH)) {
            // T1.4.3: Control Flow Agent addition
            prog->stmts[prog->count++] = parse_match_statement();
        } else {
            prog->stmts[prog->count++] = statement();
        }
    }
    
    return prog;
}

// T1.6.2: Testing Framework Agent addition - Test statement parser
static Stmt* parse_test_statement() {
    advance(); // consume 'test' token
    
    Stmt* stmt = alloc_stmt();
    stmt->type = STMT_TEST;
    
    // Parse test name
    expect(TOKEN_IDENT, "Expected test name");
    stmt->test_stmt.name = parser.previous;
    stmt->test_stmt.is_async = false;
    
    // Parse test body
    expect(TOKEN_LBRACE, "Expected '{' before test body");
    stmt->test_stmt.body = alloc_stmt();
    stmt->test_stmt.body->type = STMT_BLOCK;
    stmt->test_stmt.body->block.stmts = safe_malloc(sizeof(Stmt*) * 32);
    stmt->test_stmt.body->block.count = 0;
    
    // Parse statements until closing brace
    while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
        stmt->test_stmt.body->block.stmts[stmt->test_stmt.body->block.count++] = statement();
    }
    
    expect(TOKEN_RBRACE, "Expected '}' after test body");
    
    return stmt;
}

void init_parser() {
    parser.had_error = false;
    advance();
}

bool parser_had_error() {
    return parser.had_error;
}

// T1.4.1: While Loop AST Extension - Control Flow Agent addition
static Stmt* parse_while_statement() {
    advance(); // consume 'while' token
    
    Stmt* stmt = safe_malloc(sizeof(Stmt));
    if (!stmt) return NULL;
    
    stmt->type = STMT_WHILE;
    
    expect(TOKEN_LPAREN, "Expected '(' after 'while'");
    stmt->while_stmt.condition = expression();
    expect(TOKEN_RPAREN, "Expected ')' after while condition");
    
    stmt->while_stmt.body = statement();
    
    return stmt;
}

// T1.4.2: Break/Continue Implementation - Control Flow Agent addition
static Stmt* parse_break_statement() {
    advance(); // consume 'break' token
    
    Stmt* stmt = safe_malloc(sizeof(Stmt));
    if (!stmt) return NULL;
    
    stmt->type = STMT_BREAK;
    
    expect(TOKEN_SEMI, "Expected ';' after 'break'");
    
    return stmt;
}

static Stmt* parse_continue_statement() {
    advance(); // consume 'continue' token
    
    Stmt* stmt = safe_malloc(sizeof(Stmt));
    if (!stmt) return NULL;
    
    stmt->type = STMT_CONTINUE;
    
    expect(TOKEN_SEMI, "Expected ';' after 'continue'");
    
    return stmt;
}

// T1.4.3: Match Statement Parser - Control Flow Agent addition
static Stmt* parse_match_statement() {
    advance(); // consume 'match' token
    
    Stmt* stmt = safe_malloc(sizeof(Stmt));
    if (!stmt) return NULL;
    
    stmt->type = STMT_MATCH;
    
    // Parse the value to match against
    stmt->match_stmt.value = expression();
    
    expect(TOKEN_LBRACE, "Expected '{' after match expression");
    
    // Parse match cases
    stmt->match_stmt.case_count = 0;
    stmt->match_stmt.cases = safe_malloc(sizeof(MatchCase) * 16); // Initial capacity
    
    while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
        MatchCase* current_case = &stmt->match_stmt.cases[stmt->match_stmt.case_count];
        
        // Parse pattern - enhanced to support Some/None patterns
        Pattern* pattern = safe_malloc(sizeof(Pattern));
        
        if (match(TOKEN_SOME)) {
            // Some(pattern) - option pattern
            pattern->type = PATTERN_OPTION;
            pattern->option.is_some = true;
            
            expect(TOKEN_LPAREN, "Expected '(' after Some");
            
            // Parse inner pattern (for now, just identifier)
            Pattern* inner_pattern = safe_malloc(sizeof(Pattern));
            inner_pattern->type = PATTERN_IDENT;
            inner_pattern->ident.name = parser.current;
            expect(TOKEN_IDENT, "Expected identifier in Some pattern");
            
            pattern->option.inner = inner_pattern;
            expect(TOKEN_RPAREN, "Expected ')' after Some pattern");
        } else if (match(TOKEN_NONE)) {
            // None pattern
            pattern->type = PATTERN_OPTION;
            pattern->option.is_some = false;
            pattern->option.inner = NULL;
        } else {
            // Simple identifier pattern (fallback)
            pattern->type = PATTERN_IDENT;
            pattern->ident.name = parser.current;
            advance();
        }
        
        current_case->pattern = pattern;
        
        // Check for guard clause
        if (match(TOKEN_IF)) {
            current_case->guard = expression();
        } else {
            current_case->guard = NULL;
        }
        
        expect(TOKEN_FATARROW, "Expected '=>' after match pattern");
        
        // Parse case body
        current_case->body = statement();
        
        stmt->match_stmt.case_count++;
        
        // Optional comma
        if (check(TOKEN_COMMA)) {
            advance();
        }
    }
    
    expect(TOKEN_RBRACE, "Expected '}' after match cases");
    
    return stmt;
}

// T2.5.1: Optional Type Implementation - Type System Agent addition
// T2.5.2: Union Type Support - Type System Agent addition
static Expr* parse_type() {
    Expr* base_type;
    
    // Handle array types [type]
    if (match(TOKEN_LBRACKET)) {
        Expr* element_type = parse_type(); // Recursive call for nested arrays
        expect(TOKEN_RBRACKET, "Expected ']' after array element type");
        
        base_type = alloc_expr();
        base_type->type = EXPR_ARRAY;
        base_type->array.elements = malloc(sizeof(Expr*) * 1);
        base_type->array.elements[0] = element_type;
        base_type->array.count = 1; // Use count=1 to indicate this is a type, not literal
    } else if (check(TOKEN_IDENT)) {
        // Handle built-in types and user-defined types
        Token type_token = parser.current;
        advance();
        
        // Check for generic type instantiation: TypeName<T1, T2, ...>
        if (match(TOKEN_LT)) {
            // This is a generic type instantiation
            base_type = alloc_expr();
            base_type->type = EXPR_CALL; // Reuse EXPR_CALL for generic instantiation
            
            // Create identifier expression for the type name
            Expr* type_name_expr = alloc_expr();
            type_name_expr->type = EXPR_IDENT;
            type_name_expr->token = type_token;
            base_type->call.callee = type_name_expr;
            
            // Parse type arguments
            base_type->call.arg_count = 0;
            base_type->call.args = malloc(sizeof(Expr*) * 8);
            
            if (!check(TOKEN_GT)) {
                do {
                    base_type->call.args[base_type->call.arg_count++] = parse_type();
                } while (match(TOKEN_COMMA));
            }
            
            expect(TOKEN_GT, "Expected '>' after generic type arguments");
        } else {
            // Regular type name
            // Check for built-in types
            if (type_token.length == 3 && memcmp(type_token.start, "str", 3) == 0) {
                // Built-in string type
                base_type = alloc_expr();
                base_type->type = EXPR_IDENT;
                base_type = alloc_expr();
                base_type->type = EXPR_IDENT;
                base_type->token = type_token;
            } else if (type_token.length == 3 && memcmp(type_token.start, "int", 3) == 0) {
                // Built-in int type
                base_type = alloc_expr();
                base_type->type = EXPR_IDENT;
                base_type->token = type_token;
            } else if (type_token.length == 4 && memcmp(type_token.start, "bool", 4) == 0) {
                // Built-in bool type
                base_type = alloc_expr();
                base_type->type = EXPR_IDENT;
                base_type->token = type_token;
            } else if (type_token.length == 5 && memcmp(type_token.start, "float", 5) == 0) {
                // Built-in float type
                base_type = alloc_expr();
                base_type->type = EXPR_IDENT;
                base_type->token = type_token;
            } else {
                // User-defined type
                base_type = alloc_expr();
                base_type->type = EXPR_IDENT;
                base_type->token = type_token;
            }
        }
    } else {
        fprintf(stderr, "Error at line %d: Expected type name\n", parser.current.line);
        return NULL;
    }
    
    // Check for union type with '|' syntax (T | U | V)
    if (match(TOKEN_PIPE)) {
        Expr* union_expr = alloc_expr();
        union_expr->type = EXPR_UNION_TYPE;
        
        // Start with the base type as first union member
        union_expr->union_type.types = malloc(sizeof(Expr*) * 8); // Initial capacity
        union_expr->union_type.types[0] = base_type;
        union_expr->union_type.type_count = 1;
        
        // Parse additional union members
        do {
            Expr* next_type = parse_type(); // Recursive call
            union_expr->union_type.types[union_expr->union_type.type_count] = next_type;
            union_expr->union_type.type_count++;
        } while (match(TOKEN_PIPE));
        
        base_type = union_expr;
    }
    
    // Check for optional type suffix '?' (can be applied to union types too)
    if (match(TOKEN_QUESTION)) {
        Expr* optional_expr = alloc_expr();
        optional_expr->type = EXPR_OPTIONAL_TYPE;
        optional_expr->optional_type.inner_type = base_type;
        return optional_expr;
    }
    
    return base_type;
}

// T3.3.1: Pattern parsing for destructuring
static Pattern* parse_pattern() {
    Pattern* pattern = safe_malloc(sizeof(Pattern));
    
    // Handle struct destructuring: Point { x, y }
    if (check(TOKEN_IDENT)) {
        Token potential_struct = parser.current;
        advance();
        
        if (match(TOKEN_LBRACE)) {
            // This is a struct pattern
            pattern->type = PATTERN_STRUCT;
            pattern->struct_pat.struct_name = potential_struct;
            
            // Parse field patterns
            pattern->struct_pat.field_count = 0;
            pattern->struct_pat.field_names = safe_malloc(sizeof(Token) * 16);
            pattern->struct_pat.field_patterns = safe_malloc(sizeof(Pattern*) * 16);
            
            while (!check(TOKEN_RBRACE) && !check(TOKEN_EOF)) {
                if (pattern->struct_pat.field_count >= 16) {
                    fprintf(stderr, "Error: Too many fields in struct pattern\n");
                    break;
                }
                
                // Parse field name
                expect(TOKEN_IDENT, "Expected field name in struct pattern");
                pattern->struct_pat.field_names[pattern->struct_pat.field_count] = parser.previous;
                
                // For now, create a simple identifier pattern for the field
                Pattern* field_pattern = safe_malloc(sizeof(Pattern));
                field_pattern->type = PATTERN_IDENT;
                field_pattern->ident.name = parser.previous;
                pattern->struct_pat.field_patterns[pattern->struct_pat.field_count] = field_pattern;
                
                pattern->struct_pat.field_count++;
                
                if (!check(TOKEN_RBRACE)) {
                    expect(TOKEN_COMMA, "Expected ',' between struct pattern fields");
                }
            }
            
            expect(TOKEN_RBRACE, "Expected '}' after struct pattern");
            return pattern;
        } else {
            // This is just an identifier pattern
            pattern->type = PATTERN_IDENT;
            pattern->ident.name = potential_struct;
            return pattern;
        }
    }
    
    // Handle array destructuring: [first, second, ...rest]
    if (match(TOKEN_LBRACKET)) {
        pattern->type = PATTERN_ARRAY;
        pattern->array.element_count = 0;
        pattern->array.elements = safe_malloc(sizeof(Pattern*) * 16);
        pattern->array.has_rest = false;
        
        while (!check(TOKEN_RBRACKET) && !check(TOKEN_EOF)) {
            if (pattern->array.element_count >= 16) {
                fprintf(stderr, "Error: Too many elements in array pattern\n");
                break;
            }
            
            // Check for rest pattern: ...name
            if (match(TOKEN_DOT) && match(TOKEN_DOT) && match(TOKEN_DOT)) {
                pattern->array.has_rest = true;
                expect(TOKEN_IDENT, "Expected identifier after '...' in array pattern");
                pattern->array.rest_name = parser.previous;
                break; // Rest pattern must be last
            }
            
            // Parse element pattern (recursively)
            pattern->array.elements[pattern->array.element_count] = parse_pattern();
            pattern->array.element_count++;
            
            if (!check(TOKEN_RBRACKET)) {
                expect(TOKEN_COMMA, "Expected ',' between array pattern elements");
            }
        }
        
        expect(TOKEN_RBRACKET, "Expected ']' after array pattern");
        return pattern;
    }
    
    // Handle tuple destructuring: (first, second, third)
    if (match(TOKEN_LPAREN)) {
        pattern->type = PATTERN_TUPLE;
        pattern->tuple.element_count = 0;
        pattern->tuple.elements = safe_malloc(sizeof(Pattern*) * 16);
        
        while (!check(TOKEN_RPAREN) && !check(TOKEN_EOF)) {
            if (pattern->tuple.element_count >= 16) {
                fprintf(stderr, "Error: Too many elements in tuple pattern\n");
                break;
            }
            
            pattern->tuple.elements[pattern->tuple.element_count] = parse_pattern();
            pattern->tuple.element_count++;
            
            if (!check(TOKEN_RPAREN)) {
                expect(TOKEN_COMMA, "Expected ',' between tuple pattern elements");
            }
        }
        
        expect(TOKEN_RPAREN, "Expected ')' after tuple pattern");
        return pattern;
    }
    
    // Handle wildcard pattern: _
    if (match(TOKEN_UNDERSCORE)) {
        pattern->type = PATTERN_WILDCARD;
        return pattern;
    }
    
    // Handle literal patterns
    if (match(TOKEN_INT) || match(TOKEN_FLOAT) || match(TOKEN_STRING) || 
        match(TOKEN_TRUE) || match(TOKEN_FALSE)) {
        pattern->type = PATTERN_LITERAL;
        pattern->literal.value = parser.previous;
        return pattern;
    }
    
    // Handle Some/None patterns
    if (match(TOKEN_SOME)) {
        pattern->type = PATTERN_OPTION;
        pattern->option.is_some = true;
        
        expect(TOKEN_LPAREN, "Expected '(' after Some");
        pattern->option.inner = parse_pattern();
        expect(TOKEN_RPAREN, "Expected ')' after Some pattern");
        return pattern;
    }
    
    if (match(TOKEN_NONE)) {
        pattern->type = PATTERN_OPTION;
        pattern->option.is_some = false;
        pattern->option.inner = NULL;
        return pattern;
    }
    
    // Default: identifier pattern
    if (check(TOKEN_IDENT)) {
        pattern->type = PATTERN_IDENT;
        pattern->ident.name = parser.current;
        advance();
        return pattern;
    }
    
    // If we get here, it's an error
    fprintf(stderr, "Error: Expected pattern at line %d\n", parser.current.line);
    free(pattern);
    return NULL;
}

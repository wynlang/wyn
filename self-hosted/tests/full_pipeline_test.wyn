// Full end-to-end test: tokenize source -> verify tokens
// Tests the self-hosted tokenizer produces correct token types

fn check_digit(c: string) -> int {
    if str_eq(c, "0") == 1 { return 1 }
    if str_eq(c, "1") == 1 { return 1 }
    if str_eq(c, "2") == 1 { return 1 }
    if str_eq(c, "3") == 1 { return 1 }
    if str_eq(c, "4") == 1 { return 1 }
    if str_eq(c, "5") == 1 { return 1 }
    if str_eq(c, "6") == 1 { return 1 }
    if str_eq(c, "7") == 1 { return 1 }
    if str_eq(c, "8") == 1 { return 1 }
    if str_eq(c, "9") == 1 { return 1 }
    return 0
}

fn check_alpha(c: string) -> int {
    if str_eq(c, "_") == 1 { return 1 }
    if str_eq(c, "a") == 1 { return 1 }
    if str_eq(c, "b") == 1 { return 1 }
    if str_eq(c, "c") == 1 { return 1 }
    if str_eq(c, "d") == 1 { return 1 }
    if str_eq(c, "e") == 1 { return 1 }
    if str_eq(c, "f") == 1 { return 1 }
    if str_eq(c, "g") == 1 { return 1 }
    if str_eq(c, "h") == 1 { return 1 }
    if str_eq(c, "i") == 1 { return 1 }
    if str_eq(c, "j") == 1 { return 1 }
    if str_eq(c, "k") == 1 { return 1 }
    if str_eq(c, "l") == 1 { return 1 }
    if str_eq(c, "m") == 1 { return 1 }
    if str_eq(c, "n") == 1 { return 1 }
    if str_eq(c, "o") == 1 { return 1 }
    if str_eq(c, "p") == 1 { return 1 }
    if str_eq(c, "q") == 1 { return 1 }
    if str_eq(c, "r") == 1 { return 1 }
    if str_eq(c, "s") == 1 { return 1 }
    if str_eq(c, "t") == 1 { return 1 }
    if str_eq(c, "u") == 1 { return 1 }
    if str_eq(c, "v") == 1 { return 1 }
    if str_eq(c, "w") == 1 { return 1 }
    if str_eq(c, "x") == 1 { return 1 }
    if str_eq(c, "y") == 1 { return 1 }
    if str_eq(c, "z") == 1 { return 1 }
    return 0
}

struct Tokens {
    types: [int],
    lines: [int],
    cols: [int],
    count: int
}

// Simple tokenizer for basic expressions
fn tokenize(source: string) -> Tokens {
    var types = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    var lines = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    var cols = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    var len = string_length(source)
    var pos = 0
    var count = 0
    
    while pos < len {
        var c: string = string_char_at(source, pos)
        
        // Skip whitespace
        if str_eq(c, " ") == 1 { 
            pos = pos + 1 
        } else {
            // Numbers
            if check_digit(c) == 1 {
                types[count] = 0  // INT
                count = count + 1
                pos = pos + 1
                // Skip rest of number
                var done = 0
                while done == 0 {
                    if pos >= len { done = 1 }
                    else {
                        var d: string = string_char_at(source, pos)
                        if check_digit(d) == 1 { pos = pos + 1 }
                        else { done = 1 }
                    }
                }
            } else {
                // Operators
                if str_eq(c, "+") == 1 { types[count] = 23; count = count + 1 }
                else { if str_eq(c, "-") == 1 { types[count] = 24; count = count + 1 }
                else { if str_eq(c, "*") == 1 { types[count] = 25; count = count + 1 }
                else { if str_eq(c, "/") == 1 { types[count] = 26; count = count + 1 }
                } } }
                pos = pos + 1
            }
        }
    }
    
    // Add EOF
    types[count] = 10
    count = count + 1
    
    return Tokens { types: types, lines: lines, cols: cols, count: count }
}

fn main() -> int {
    print("=== Full Pipeline Test ===\n")
    
    // Test 1: Simple expression
    print("Test 1: 1 + 2\n")
    var t1 = tokenize("1 + 2")
    // Expected: INT(0), PLUS(23), INT(0), EOF(10)
    if t1.count != 4 { print("FAIL: count\n"); return 1 }
    if t1.types[0] != 0 { print("FAIL: t1[0]\n"); return 2 }
    if t1.types[1] != 23 { print("FAIL: t1[1]\n"); return 3 }
    if t1.types[2] != 0 { print("FAIL: t1[2]\n"); return 4 }
    if t1.types[3] != 10 { print("FAIL: t1[3]\n"); return 5 }
    print("PASS\n\n")
    
    // Test 2: Multiple operators
    print("Test 2: 1 + 2 * 3\n")
    var t2 = tokenize("1 + 2 * 3")
    // Expected: INT(0), PLUS(23), INT(0), STAR(25), INT(0), EOF(10)
    if t2.count != 6 { print("FAIL: count\n"); return 6 }
    if t2.types[0] != 0 { print("FAIL: t2[0]\n"); return 7 }
    if t2.types[1] != 23 { print("FAIL: t2[1]\n"); return 8 }
    if t2.types[2] != 0 { print("FAIL: t2[2]\n"); return 9 }
    if t2.types[3] != 25 { print("FAIL: t2[3]\n"); return 10 }
    if t2.types[4] != 0 { print("FAIL: t2[4]\n"); return 11 }
    if t2.types[5] != 10 { print("FAIL: t2[5]\n"); return 12 }
    print("PASS\n\n")
    
    print("=== All Pipeline Tests PASS ===\n")
    return 0
}

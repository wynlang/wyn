// T5.4.1: Advanced Build System Integration in Wyn
// Complete build system with project management and dependency resolution

import "io"
import "string"
import "collections"
import "json"

// Build system structures
struct BuildConfig {
    project_name: String,
    version: String,
    target_type: TargetType,
    source_dirs: Vec<String>,
    dependencies: Vec<Dependency>,
    build_flags: Vec<String>,
    optimization_level: OptimizationLevel
}

enum TargetType {
    Executable,
    Library,
    StaticLibrary,
    DynamicLibrary
}

struct Dependency {
    name: String,
    version: String,
    source: DependencySource
}

enum DependencySource {
    Local(String),
    Git(String),
    Registry(String)
}

struct BuildSystem {
    config: BuildConfig,
    cache: BuildCache,
    targets: Vec<BuildTarget>
}

struct BuildTarget {
    name: String,
    sources: Vec<String>,
    output: String,
    dependencies: Vec<String>
}

struct BuildCache {
    file_hashes: HashMap<String, String>,
    build_timestamps: HashMap<String, i64>,
    dependency_graph: HashMap<String, Vec<String>>
}

// Initialize build system
fn init_build_system(project_dir: &str) -> Result<BuildSystem, String> {
    let config_path = format!("{}/wyn.toml", project_dir)
    
    let config = if file_exists(&config_path) {
        load_build_config(&config_path)?
    } else {
        create_default_config(project_dir)
    }
    
    Ok(BuildSystem {
        config,
        cache: BuildCache {
            file_hashes: HashMap::new(),
            build_timestamps: HashMap::new(),
            dependency_graph: HashMap::new()
        },
        targets: Vec::new()
    })
}

fn create_default_config(project_dir: &str) -> BuildConfig {
    let project_name = std::path::Path::new(project_dir)
        .file_name()
        .unwrap_or_default()
        .to_string_lossy()
        .to_string()
    
    BuildConfig {
        project_name,
        version: "0.1.0".to_string(),
        target_type: TargetType::Executable,
        source_dirs: vec!["src".to_string()],
        dependencies: Vec::new(),
        build_flags: vec!["-O2".to_string()],
        optimization_level: OptimizationLevel::O2
    }
}

// Build project
fn build_project(build_system: &mut BuildSystem) -> Result<(), String> {
    println!("ðŸ”¨ Building project: {}", build_system.config.project_name)
    
    // 1. Resolve dependencies
    resolve_dependencies(build_system)?
    
    // 2. Analyze source files
    analyze_sources(build_system)?
    
    // 3. Check what needs rebuilding
    let rebuild_targets = determine_rebuild_targets(build_system)?
    
    // 4. Build targets in dependency order
    for target in &rebuild_targets {
        build_target(build_system, target)?
    }
    
    // 5. Link final executable/library
    link_final_output(build_system)?
    
    println!("âœ… Build completed successfully")
    Ok(())
}

fn resolve_dependencies(build_system: &mut BuildSystem) -> Result<(), String> {
    println!("ðŸ“¦ Resolving dependencies...")
    
    for dep in &build_system.config.dependencies {
        match &dep.source {
            DependencySource::Local(path) => {
                println!("  ðŸ“ Local dependency: {} -> {}", dep.name, path)
                // Verify local dependency exists
                if !std::path::Path::new(path).exists() {
                    return Err(format!("Local dependency not found: {}", path))
                }
            },
            DependencySource::Git(url) => {
                println!("  ðŸŒ Git dependency: {} -> {}", dep.name, url)
                // Clone or update git dependency
                clone_git_dependency(&dep.name, url)?
            },
            DependencySource::Registry(registry) => {
                println!("  ðŸ“š Registry dependency: {} -> {}", dep.name, registry)
                // Download from package registry
                download_registry_dependency(&dep.name, &dep.version, registry)?
            }
        }
    }
    
    Ok(())
}

fn analyze_sources(build_system: &mut BuildSystem) -> Result<(), String> {
    println!("ðŸ” Analyzing source files...")
    
    build_system.targets.clear()
    
    for source_dir in &build_system.config.source_dirs {
        let wyn_files = find_wyn_files(source_dir)?
        
        for file in wyn_files {
            let target = BuildTarget {
                name: file.clone(),
                sources: vec![file.clone()],
                output: format!("{}.o", file),
                dependencies: extract_dependencies(&file)?
            }
            build_system.targets.push(target)
        }
    }
    
    println!("  ðŸ“„ Found {} source files", build_system.targets.len())
    Ok(())
}

fn determine_rebuild_targets(build_system: &BuildSystem) -> Result<Vec<String>, String> {
    let mut rebuild_targets = Vec::new()
    
    for target in &build_system.targets {
        if needs_rebuild(build_system, target)? {
            rebuild_targets.push(target.name.clone())
        }
    }
    
    println!("ðŸ”„ {} targets need rebuilding", rebuild_targets.len())
    Ok(rebuild_targets)
}

fn needs_rebuild(build_system: &BuildSystem, target: &BuildTarget) -> Result<bool, String> {
    // Check if output exists
    if !std::path::Path::new(&target.output).exists() {
        return Ok(true)
    }
    
    // Check if source is newer than output
    let source_time = get_file_modified_time(&target.sources[0])?
    let output_time = get_file_modified_time(&target.output)?
    
    if source_time > output_time {
        return Ok(true)
    }
    
    // Check if dependencies changed
    for dep in &target.dependencies {
        if let Some(cached_hash) = build_system.cache.file_hashes.get(dep) {
            let current_hash = calculate_file_hash(dep)?
            if cached_hash != &current_hash {
                return Ok(true)
            }
        } else {
            return Ok(true) // No cached hash, need to rebuild
        }
    }
    
    Ok(false)
}

fn build_target(build_system: &mut BuildSystem, target_name: &str) -> Result<(), String> {
    let target = build_system.targets.iter()
        .find(|t| t.name == target_name)
        .ok_or_else(|| format!("Target not found: {}", target_name))?
    
    println!("  ðŸ”¨ Building: {}", target.name)
    
    // Compile Wyn source to object file
    let mut cmd = format!("wyn-compile {} -o {}", target.sources[0], target.output)
    
    // Add build flags
    for flag in &build_system.config.build_flags {
        cmd.push(' ')
        cmd.push_str(flag)
    }
    
    // Execute build command (simplified - in real implementation would use proper process execution)
    println!("    ðŸ“ Command: {}", cmd)
    
    // Update cache
    let file_hash = calculate_file_hash(&target.sources[0])?
    build_system.cache.file_hashes.insert(target.sources[0].clone(), file_hash)
    build_system.cache.build_timestamps.insert(target.name.clone(), get_current_timestamp())
    
    Ok(())
}

fn link_final_output(build_system: &BuildSystem) -> Result<(), String> {
    println!("ðŸ”— Linking final output...")
    
    let output_name = match build_system.config.target_type {
        TargetType::Executable => build_system.config.project_name.clone(),
        TargetType::Library => format!("lib{}.a", build_system.config.project_name),
        TargetType::StaticLibrary => format!("lib{}.a", build_system.config.project_name),
        TargetType::DynamicLibrary => format!("lib{}.so", build_system.config.project_name)
    }
    
    let mut link_cmd = match build_system.config.target_type {
        TargetType::Executable => format!("gcc -o {}", output_name),
        TargetType::StaticLibrary => format!("ar rcs {}", output_name),
        TargetType::DynamicLibrary => format!("gcc -shared -o {}", output_name)
    }
    
    // Add all object files
    for target in &build_system.targets {
        link_cmd.push(' ')
        link_cmd.push_str(&target.output)
    }
    
    println!("  ðŸ“ Link command: {}", link_cmd)
    println!("âœ… Created: {}", output_name)
    
    Ok(())
}

// Project management functions
fn create_new_project(name: &str, project_type: TargetType) -> Result<(), String> {
    println!("ðŸ“ Creating new Wyn project: {}", name)
    
    // Create project directory structure
    std::fs::create_dir_all(format!("{}/src", name)).map_err(|e| e.to_string())?
    std::fs::create_dir_all(format!("{}/tests", name)).map_err(|e| e.to_string())?
    
    // Create wyn.toml config file
    let config = BuildConfig {
        project_name: name.to_string(),
        version: "0.1.0".to_string(),
        target_type: project_type,
        source_dirs: vec!["src".to_string()],
        dependencies: Vec::new(),
        build_flags: vec!["-O2".to_string()],
        optimization_level: OptimizationLevel::O2
    }
    
    save_build_config(&format!("{}/wyn.toml", name), &config)?
    
    // Create main.wyn file
    let main_content = match project_type {
        TargetType::Executable => {
            r#"fn main() -> int {
    println("Hello, Wyn!")
    return 0
}"#
        },
        _ => {
            r#"// Library code
pub fn hello() -> string {
    return "Hello from Wyn library!"
}"#
        }
    }
    
    std::fs::write(format!("{}/src/main.wyn", name), main_content).map_err(|e| e.to_string())?
    
    println!("âœ… Project '{}' created successfully", name)
    Ok(())
}

// Helper functions
fn find_wyn_files(dir: &str) -> Result<Vec<String>, String> {
    let mut files = Vec::new()
    
    for entry in std::fs::read_dir(dir).map_err(|e| e.to_string())? {
        let entry = entry.map_err(|e| e.to_string())?
        let path = entry.path()
        
        if path.extension().and_then(|s| s.to_str()) == Some("wyn") {
            files.push(path.to_string_lossy().to_string())
        }
    }
    
    Ok(files)
}

fn extract_dependencies(file: &str) -> Result<Vec<String>, String> {
    let content = std::fs::read_to_string(file).map_err(|e| e.to_string())?
    let mut deps = Vec::new()
    
    for line in content.lines() {
        if line.trim().starts_with("import") {
            // Extract import dependencies (simplified)
            if let Some(dep) = line.split('"').nth(1) {
                deps.push(format!("{}.wyn", dep))
            }
        }
    }
    
    Ok(deps)
}

fn calculate_file_hash(file: &str) -> Result<String, String> {
    let content = std::fs::read(file).map_err(|e| e.to_string())?
    // Simplified hash calculation
    Ok(format!("{:x}", content.len()))
}

fn get_file_modified_time(file: &str) -> Result<i64, String> {
    let metadata = std::fs::metadata(file).map_err(|e| e.to_string())?
    Ok(metadata.modified().unwrap().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() as i64)
}

fn get_current_timestamp() -> i64 {
    std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() as i64
}

fn file_exists(path: &str) -> bool {
    std::path::Path::new(path).exists()
}

fn clone_git_dependency(name: &str, url: &str) -> Result<(), String> {
    println!("    ðŸ”„ Cloning {} from {}", name, url)
    // In real implementation, would use git commands
    Ok(())
}

fn download_registry_dependency(name: &str, version: &str, registry: &str) -> Result<(), String> {
    println!("    ðŸ“¥ Downloading {} v{} from {}", name, version, registry)
    // In real implementation, would download from package registry
    Ok(())
}

fn load_build_config(path: &str) -> Result<BuildConfig, String> {
    // In real implementation, would parse TOML file
    Ok(create_default_config("."))
}

fn save_build_config(path: &str, config: &BuildConfig) -> Result<(), String> {
    let toml_content = format!(r#"
[package]
name = "{}"
version = "{}"

[build]
target_type = "{:?}"
source_dirs = {:?}
build_flags = {:?}
"#, config.project_name, config.version, config.target_type, config.source_dirs, config.build_flags)
    
    std::fs::write(path, toml_content).map_err(|e| e.to_string())
}

// C interface for build system integration
extern "C" {
    fn wyn_build_system_init(project_dir: *const char) -> *mut BuildSystem
    fn wyn_build_project(build_system: *mut BuildSystem) -> i32
    fn wyn_create_project(name: *const char, project_type: i32) -> i32
    fn wyn_build_system_cleanup(build_system: *mut BuildSystem)
}

fn wyn_build_system_init(project_dir: *const char) -> *mut BuildSystem {
    unsafe {
        let dir = CStr::from_ptr(project_dir).to_string_lossy()
        match init_build_system(&dir) {
            Ok(build_system) => Box::into_raw(Box::new(build_system)),
            Err(_) => std::ptr::null_mut()
        }
    }
}

fn wyn_build_project(build_system: *mut BuildSystem) -> i32 {
    unsafe {
        let build_system_ref = &mut *build_system
        match build_project(build_system_ref) {
            Ok(()) => 0,
            Err(_) => 1
        }
    }
}

fn wyn_create_project(name: *const char, project_type: i32) -> i32 {
    unsafe {
        let name_str = CStr::from_ptr(name).to_string_lossy()
        let target_type = match project_type {
            0 => TargetType::Executable,
            1 => TargetType::Library,
            2 => TargetType::StaticLibrary,
            3 => TargetType::DynamicLibrary,
            _ => TargetType::Executable
        }
        
        match create_new_project(&name_str, target_type) {
            Ok(()) => 0,
            Err(_) => 1
        }
    }
}

fn wyn_build_system_cleanup(build_system: *mut BuildSystem) {
    unsafe {
        Box::from_raw(build_system)
    }
}

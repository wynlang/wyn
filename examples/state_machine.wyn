// State Machine - Demonstrates enums and pattern matching

enum State {
    IDLE,
    RUNNING,
    PAUSED,
    STOPPED
}

fn next_state(current: State) -> State {
    return match current {
        IDLE => State::RUNNING,
        RUNNING => State::PAUSED,
        PAUSED => State::RUNNING,
        STOPPED => State::IDLE
    };
}

fn state_to_int(s: State) -> int {
    return match s {
        IDLE => 0,
        RUNNING => 1,
        PAUSED => 2,
        STOPPED => 3
    };
}

fn main() -> int {
    let s1 = State::IDLE;
    let s2 = next_state(s1);
    let s3 = next_state(s2);
    let s4 = next_state(s3);
    
    return state_to_int(s2) + state_to_int(s3) + state_to_int(s4);
}
